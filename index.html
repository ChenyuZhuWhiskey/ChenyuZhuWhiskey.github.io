<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Chenyu">
<meta property="og:type" content="website">
<meta property="og:title" content="Chenyu&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Chenyu&#39;s Blog">
<meta property="og:description" content="Chenyu">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Chenyu ZHU">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Chenyu's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Chenyu's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Aera of Pure Physics, Mathematics, Computer Science and Engineering</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/21/flex-lexer%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chenyu ZHU">
      <meta itemprop="description" content="Chenyu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chenyu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/21/flex-lexer%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">flex lexer分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-21 15:16:37" itemprop="dateCreated datePublished" datetime="2020-06-21T15:16:37+08:00">2020-06-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">编译原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="flex-lexer分析"><a href="#flex-lexer分析" class="headerlink" title="flex lexer分析"></a>flex lexer分析</h1><p>flex会根据你定义的正则表达式匹配到相应字段，然后根据你定义的函数进行操作，返回相应的token。</p>
<p>为了了解flex如何work的，我们新建一个空的flex规则文件<code>null.flex</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%%</span><br></pre></td></tr></table></figure>

<p>然后运行命令<code>flex null.flex</code>生成<code>lex.yy.c</code>文件。</p>
<p>接下来逐行分析它的code：</p>
<p>首先是一些flex的版本相关的宏：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FLEX_SCANNER</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> YY_FLEX_MAJOR_VERSION 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> YY_FLEX_MINOR_VERSION 6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> YY_FLEX_SUBMINOR_VERSION 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> YY_FLEX_SUBMINOR_VERSION &gt; 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FLEX_BETA</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>然后将一些type define成自己的格式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __STDC_LIMIT_MACROS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __STDC_LIMIT_MACROS 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int8_t</span> <span class="keyword">flex_int8_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint8_t</span> <span class="keyword">flex_uint8_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int16_t</span> <span class="keyword">flex_int16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint16_t</span> <span class="keyword">flex_uint16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int32_t</span> <span class="keyword">flex_int32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> <span class="keyword">flex_uint32_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">signed</span> <span class="keyword">char</span> <span class="keyword">flex_int8_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> short <span class="keyword">int</span> <span class="keyword">flex_int16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">flex_int32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="keyword">flex_uint8_t</span>; </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> short <span class="keyword">int</span> <span class="keyword">flex_uint16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">flex_uint32_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> INT8_MIN</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT8_MIN               (-128)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> INT16_MIN</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT16_MIN              (-32767-1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> INT32_MIN</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT32_MIN              (-2147483647-1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> INT8_MAX</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT8_MAX               (127)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> INT16_MAX</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT16_MAX              (32767)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> INT32_MAX</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT32_MAX              (2147483647)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> UINT8_MAX</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UINT8_MAX              (255U)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> UINT16_MAX</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UINT16_MAX             (65535U)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> UINT32_MAX</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UINT32_MAX             (4294967295U)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>然后定义EOF的宏:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> YY_NULL 0</span></span><br></pre></td></tr></table></figure>

<p>将<code>signed char</code>安全转换为<code>unsigned int</code>的宏<code>YY_SC_TO_UI</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)</span></span><br></pre></td></tr></table></figure>

<p>start condition中用的BEGIN():</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define BEGIN (yy_start) &#x3D; 1 + 2 *</span><br></pre></td></tr></table></figure>

<p>在后面的代码可以看出，这些start condition定义的关键词都被定义成了宏，比如我们有两个start condition <code>COMMENT</code>和<code>STRING</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INITIAL 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COMMENT 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STRING 2</span></span><br></pre></td></tr></table></figure>

<p>这时<code>BEGIN(COMMENT)</code>就等价于：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(yy_start) = <span class="number">1</span> + <span class="number">2</span> * COMMENT</span><br></pre></td></tr></table></figure>

<p>之后就可以得到相应的<code>YY_STATE</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define YY_START (((yy_start) - 1) &#x2F; 2)</span><br><span class="line">#define YYSTATE YY_START</span><br></pre></td></tr></table></figure>

<p>略去其他不重要的宏，接下来看两个<code>FILE</code>指针<code>yyin</code>和<code>yyout</code>，可以看出<code>yyin</code>指向了<code>stdin</code>，<code>yyout</code>指向了<code>stdout</code>，分别对应了标准输入输出流：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> FILE *yyin, *yyout;</span><br><span class="line"><span class="comment">/*a lot of code*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> YY_STDINIT</span></span><br><span class="line">    yyin = <span class="built_in">stdin</span>;</span><br><span class="line">    yyout = <span class="built_in">stdout</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    yyin = (FILE *) <span class="number">0</span>;</span><br><span class="line">    yyout = (FILE *) <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>接下来的代码就可以看出，flex的lexer是使用自顶向下的表驱动预测分析法来实现匹配的，关于这里面的预测分析，LL(1)文法等定义见编译原理的相关教材。</p>
<p>首先要实现表驱动预测分析，就要定义读入text的方法，理论上是一个个character读入，但为了效率起见，flex将它们批量读取存入了buffer中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#ifndef YY_INPUT</span><br><span class="line">#define YY_INPUT(buf,result,max_size) \</span><br><span class="line">	if ( YY_CURRENT_BUFFER_LVALUE-&gt;yy_is_interactive ) \</span><br><span class="line">		&#123; \</span><br><span class="line">		int c &#x3D; &#39;*&#39;; \</span><br><span class="line">		size_t n; \</span><br><span class="line">		for ( n &#x3D; 0; n &lt; max_size &amp;&amp; \</span><br><span class="line">			     (c &#x3D; getc( yyin )) !&#x3D; EOF &amp;&amp; c !&#x3D; &#39;\n&#39;; ++n ) \</span><br><span class="line">			buf[n] &#x3D; (char) c; \</span><br><span class="line">		if ( c &#x3D;&#x3D; &#39;\n&#39; ) \</span><br><span class="line">			buf[n++] &#x3D; (char) c; \</span><br><span class="line">		if ( c &#x3D;&#x3D; EOF &amp;&amp; ferror( yyin ) ) \</span><br><span class="line">			YY_FATAL_ERROR( &quot;input in flex scanner failed&quot; ); \</span><br><span class="line">		result &#x3D; n; \</span><br><span class="line">		&#125; \</span><br><span class="line">	else \</span><br><span class="line">		&#123; \</span><br><span class="line">		errno&#x3D;0; \</span><br><span class="line">		while ( (result &#x3D; fread(buf, 1, max_size, yyin))&#x3D;&#x3D;0 &amp;&amp; ferror(yyin)) \</span><br><span class="line">			&#123; \</span><br><span class="line">			if( errno !&#x3D; EINTR) \</span><br><span class="line">				&#123; \</span><br><span class="line">				YY_FATAL_ERROR( &quot;input in flex scanner failed&quot; ); \</span><br><span class="line">				break; \</span><br><span class="line">				&#125; \</span><br><span class="line">			errno&#x3D;0; \</span><br><span class="line">			clearerr(yyin); \</span><br><span class="line">			&#125; \</span><br><span class="line">		&#125;\</span><br><span class="line">\</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>这里就要吐槽一下它的缩进了，简直惨不忍睹。如果你觉得这种读取方法很复杂的话，可以rewrite自己的<code>YY_INPUT</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> YY_INPUT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> YY_INPUT(buf,result,max_size) \</span></span><br><span class="line">    <span class="keyword">if</span> ( (result = fread( (<span class="keyword">char</span>*)buf, <span class="keyword">sizeof</span>(<span class="keyword">char</span>), max_size, fin)) &lt; <span class="number">0</span>) \</span><br><span class="line">        YY_FATAL_ERROR( <span class="string">"read() in flex scanner failed"</span>);</span><br></pre></td></tr></table></figure>

<p>这段代码引自参考文献[1]。</p>
<p>为什么说它用的是表驱动法呢？从它在静态区cache了一些预测分析表的常量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> yyconst <span class="keyword">flex_int16_t</span> yy_accept[<span class="number">6</span>] = &#123;...&#125;;</span><br><span class="line"><span class="keyword">static</span> yyconst YY_CHAR yy_ec[<span class="number">256</span>] = &#123;...&#125;;</span><br><span class="line"><span class="keyword">static</span> yyconst YY_CHAR yy_meta[<span class="number">2</span>] = &#123;...&#125;;</span><br><span class="line"><span class="keyword">static</span> yyconst <span class="keyword">flex_uint16_t</span> yy_base[<span class="number">7</span>] = &#123;...&#125;;</span><br><span class="line"><span class="keyword">static</span> yyconst <span class="keyword">flex_int16_t</span> yy_def[<span class="number">7</span>] = &#123;...&#125;;</span><br><span class="line"><span class="keyword">static</span> yyconst <span class="keyword">flex_uint16_t</span> yy_nxt[<span class="number">5</span>] = &#123;...&#125;;</span><br><span class="line"><span class="keyword">static</span> yyconst <span class="keyword">flex_int16_t</span> yy_chk[<span class="number">5</span>] = &#123;...&#125;;</span><br></pre></td></tr></table></figure>

<p>以及定义了将缓冲区变量压栈和出栈的一系列操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">yypush_buffer_state</span> <span class="params">(YY_BUFFER_STATE new_buffer )</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">/*a lof of code*/</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">yypop_buffer_state</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">/*a lof of code*/</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">yyensure_buffer_stack</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">/*a lof of code*/</span>&#125;</span><br></pre></td></tr></table></figure>

<p>再对比下自顶向下表驱动法的算法结构：</p>
<p><img src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/flex%E8%A7%A3%E6%9E%90/top_down_push_pop.png" alt="top-down-push-pop"></p>
<p>就一目了然了。</p>
<p>接下来就来看这个算法flex具体是如何实现的，它过程就在于<code>yylex()</code>这个函数，大致的框架如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> YY_DECL int yylex (void)</span></span><br><span class="line"><span class="comment">/*a lot of code*/</span></span><br><span class="line">YY_DECL</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// initialize</span></span><br><span class="line">    <span class="comment">// crate stack</span></span><br><span class="line">    <span class="comment">// load buffer</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        yy_match:</span><br><span class="line">        	<span class="comment">/* 在这里不断进行状态转移，直至无法继续转移 */</span></span><br><span class="line">        	<span class="comment">/* 用到了前面提的YY_SC_TO_UI*/</span></span><br><span class="line">        	<span class="keyword">do</span>&#123;</span><br><span class="line">				YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;</span><br><span class="line">				<span class="keyword">if</span> ( yy_accept[yy_current_state] )&#123;</span><br><span class="line">					(yy_last_accepting_state) = yy_current_state;</span><br><span class="line">					(yy_last_accepting_cpos) = yy_cp;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">while</span> ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )</span><br><span class="line">				&#123;</span><br><span class="line">					yy_current_state = (<span class="keyword">int</span>) yy_def[yy_current_state];</span><br><span class="line">					<span class="keyword">if</span> ( yy_current_state &gt;= <span class="number">6</span> )</span><br><span class="line">					yy_c = yy_meta[(<span class="keyword">unsigned</span> <span class="keyword">int</span>) yy_c];</span><br><span class="line">				&#125;</span><br><span class="line">				yy_current_state = yy_nxt[yy_base[yy_current_state] + (<span class="keyword">unsigned</span> <span class="keyword">int</span>) yy_c];</span><br><span class="line">				++yy_cp;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">while</span> ( yy_base[yy_current_state] != <span class="number">3</span> );</span><br><span class="line">       	yy_find_action:</span><br><span class="line">        	<span class="comment">/*根据yy_current_state返回对应的yy_act*/</span></span><br><span class="line">        	<span class="comment">/*检查是否停止在接受状态(yy_act==0的情况)*/</span></span><br><span class="line">        	<span class="comment">/*yy_act == 1 表示accept*/</span></span><br><span class="line">        	<span class="comment">/*具体见do_action*/</span></span><br><span class="line">        	yy_act = yy_accept[yy_current_state];</span><br><span class="line">            <span class="keyword">if</span> ( yy_act == <span class="number">0</span> )</span><br><span class="line">                &#123; <span class="comment">/* have to back up */</span></span><br><span class="line">                    yy_cp = (yy_last_accepting_cpos);</span><br><span class="line">                    yy_current_state = (yy_last_accepting_state);</span><br><span class="line">                    yy_act = yy_accept[yy_current_state];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            YY_DO_BEFORE_ACTION;</span><br><span class="line">        do_action:</span><br><span class="line">        	<span class="comment">/*处理各种yy_act*/</span></span><br><span class="line">        <span class="keyword">switch</span>(yy_act)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/*读到EOF*/</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">/*accept*/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>do_action</code>中，<code>yy_act</code>只有0和1两种情况，即读到非EOF的直接accept，读到EOF转<code>case 0</code>。因为这是一个空的规则文件，假如我们用带有规则的<code>xxx.flex</code>生成code，这些规则中的正则表达式匹配方法会表现到静态区中cache的预测分析表中，匹配到的action会体现在这个<code>switch-case</code>语句中。</p>
<p>为了验证以上的说明，我们定义一个用来匹配能够解释为十进制数字符串的规则,放到文件<code>test.flex</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WHITE   &quot; &quot;|\t|\f|\r|\v</span><br><span class="line">%%</span><br><span class="line">&#123;WHITE&#125;*[+-]?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))([Ee][+-]?[0-9]+)?&#123;WHITE&#125;* &#123;return true;&#125;</span><br><span class="line">. &#123;return false;&#125;</span><br><span class="line">%%</span><br></pre></td></tr></table></figure>

<p>对应的DFA图如下：</p>
<p><img src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/flex%E8%A7%A3%E6%9E%90/DFA.png" alt="DFA"></p>
<p>这个例子来自参考文献[1].</p>
<p>flex为了减少内存开销，对原来的状态表进行了压缩，因此在空规则生成的文件中，我们能看到很多个静态区常量(见上面)，为了看到原本的状态表，我们使用 <code>-Cf</code>进行编译：<code>flex -Cf test.flex</code> ,然后可以看到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static yyconst flex_int16_t yy_nxt[][128] &#x3D; &#123;...&#125;;</span><br><span class="line">static yyconst flex_int16_t yy_accept[9] &#x3D; &#123;...&#125;;</span><br></pre></td></tr></table></figure>

<p>其中<code>flex_int16_t yy_nxt[][128]</code>就是原来的状态表。在<code>yylex()</code>中，匹配的过程是这么写的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">yy_match:</span><br><span class="line">		<span class="keyword">while</span> ( (yy_current_state = yy_nxt[yy_current_state][ YY_SC_TO_UI(*yy_cp) ]) &gt; <span class="number">0</span> )</span><br><span class="line">			&#123;</span><br><span class="line">			<span class="keyword">if</span> ( yy_accept[yy_current_state] )</span><br><span class="line">				&#123;</span><br><span class="line">				(yy_last_accepting_state) = yy_current_state;</span><br><span class="line">				(yy_last_accepting_cpos) = yy_cp;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			++yy_cp;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		yy_current_state = -yy_current_state;</span><br><span class="line"></span><br><span class="line">yy_find_action:</span><br><span class="line">		yy_act = yy_accept[yy_current_state];</span><br><span class="line"></span><br><span class="line">		YY_DO_BEFORE_ACTION;</span><br></pre></td></tr></table></figure>

<p>现在我们只要照着它稍微修改一下，就能得到一个判断字符串是否能作为数字的程序了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> yyconst const</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">flex_int16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">flex_int32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> YY_CHAR;</span><br><span class="line"><span class="keyword">static</span> yyconst <span class="keyword">flex_int16_t</span> yy_nxt[][<span class="number">128</span>] = &#123;...&#125;;</span><br><span class="line"><span class="keyword">static</span> yyconst <span class="keyword">flex_int16_t</span> yy_accept[<span class="number">21</span>] = &#123;...&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isNumber</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> yy_current_state = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i ) &#123;</span><br><span class="line">        yy_current_state = yy_nxt[yy_current_state][YY_SC_TO_UI(s[i])];</span><br><span class="line">        <span class="keyword">if</span> ( yy_current_state &lt; <span class="number">0</span> ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> yy_accept[yy_current_state] == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里只需要判断新的current state是否大于0.没用必要查询是否accept(因为match时小于0直接跳出循环，说明匹配失败)。</p>
<p>对于压缩版本的，也可以有如下的对应。</p>
<p><code>yylex()</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">yy_match:</span><br><span class="line">		<span class="keyword">do</span></span><br><span class="line">			&#123;</span><br><span class="line">			YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;</span><br><span class="line">			<span class="keyword">if</span> ( yy_accept[yy_current_state] )</span><br><span class="line">				&#123;</span><br><span class="line">				(yy_last_accepting_state) = yy_current_state;</span><br><span class="line">				(yy_last_accepting_cpos) = yy_cp;</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">while</span> ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )</span><br><span class="line">				&#123;</span><br><span class="line">				yy_current_state = (<span class="keyword">int</span>) yy_def[yy_current_state];</span><br><span class="line">				<span class="keyword">if</span> ( yy_current_state &gt;= <span class="number">22</span> )</span><br><span class="line">					yy_c = yy_meta[(<span class="keyword">unsigned</span> <span class="keyword">int</span>) yy_c];</span><br><span class="line">				&#125;</span><br><span class="line">			yy_current_state = yy_nxt[yy_base[yy_current_state] + (<span class="keyword">unsigned</span> <span class="keyword">int</span>) yy_c];</span><br><span class="line">			++yy_cp;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">while</span> ( yy_base[yy_current_state] != <span class="number">43</span> );</span><br><span class="line"></span><br><span class="line">yy_find_action:</span><br><span class="line">		yy_act = yy_accept[yy_current_state];</span><br><span class="line">		<span class="keyword">if</span> ( yy_act == <span class="number">0</span> )</span><br><span class="line">			&#123; <span class="comment">/* have to back up */</span></span><br><span class="line">			yy_cp = (yy_last_accepting_cpos);</span><br><span class="line">			yy_current_state = (yy_last_accepting_state);</span><br><span class="line">			yy_act = yy_accept[yy_current_state];</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		YY_DO_BEFORE_ACTION;</span><br></pre></td></tr></table></figure>

<p><code>valid_number</code>程序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> yyconst const</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">flex_int16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">flex_int32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> YY_CHAR;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> yyconst <span class="keyword">flex_int16_t</span> yy_accept[<span class="number">6</span>] = &#123;...&#125;;</span><br><span class="line"><span class="keyword">static</span> yyconst YY_CHAR yy_ec[<span class="number">256</span>] = &#123;...&#125;;</span><br><span class="line"><span class="keyword">static</span> yyconst YY_CHAR yy_meta[<span class="number">2</span>] = &#123;...&#125;;</span><br><span class="line"><span class="keyword">static</span> yyconst <span class="keyword">flex_uint16_t</span> yy_base[<span class="number">7</span>] = &#123;...&#125;;</span><br><span class="line"><span class="keyword">static</span> yyconst <span class="keyword">flex_int16_t</span> yy_def[<span class="number">7</span>] = &#123;...&#125;;</span><br><span class="line"><span class="keyword">static</span> yyconst <span class="keyword">flex_uint16_t</span> yy_nxt[<span class="number">5</span>] = &#123;...&#125;;</span><br><span class="line"><span class="keyword">static</span> yyconst <span class="keyword">flex_int16_t</span> yy_chk[<span class="number">5</span>] = &#123;...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isNumber</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> yy_current_state = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i)&#123;</span><br><span class="line">        YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;</span><br><span class="line">        <span class="keyword">while</span> ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )</span><br><span class="line">        &#123;</span><br><span class="line">            yy_current_state = (<span class="keyword">int</span>) yy_def[yy_current_state];</span><br><span class="line">            <span class="keyword">if</span> ( yy_current_state &gt;= <span class="number">22</span> )</span><br><span class="line">                yy_c = yy_meta[(<span class="keyword">unsigned</span> <span class="keyword">int</span>) yy_c];</span><br><span class="line">        &#125;</span><br><span class="line">        yy_current_state = yy_nxt[yy_base[yy_current_state] + (<span class="keyword">unsigned</span> <span class="keyword">int</span>) yy_c];</span><br><span class="line">        <span class="keyword">return</span>(yy_accept[yy_current_state]);</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要判断current state是否能被accept(即返回1)，当然根据while循环条件也可以。</p>
<p>References：</p>
<p>[1].Flex技巧总结 &amp;&amp; [LeetCode]Valid Number题解  <a href="https://blog.finaltheory.me/research/Flex-Tricks.html" target="_blank" rel="noopener">https://blog.finaltheory.me/research/Flex-Tricks.html</a> </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/05/the-art-of-software-security-assessment-Chap5-translate/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chenyu ZHU">
      <meta itemprop="description" content="Chenyu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chenyu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/05/the-art-of-software-security-assessment-Chap5-translate/" class="post-title-link" itemprop="url">the art of software security assessment Chap5. translate</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-05 23:08:57" itemprop="dateCreated datePublished" datetime="2020-06-05T23:08:57+08:00">2020-06-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-10 22:25:36" itemprop="dateModified" datetime="2020-06-10T22:25:36+08:00">2020-06-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="7-第二部分-软件漏洞"><a href="#7-第二部分-软件漏洞" class="headerlink" title="7.第二部分 软件漏洞"></a>7.第二部分 软件漏洞</h2><h3 id="7-1-第五章-内存损坏-（memory-corruption）"><a href="#7-1-第五章-内存损坏-（memory-corruption）" class="headerlink" title="7.1 第五章 内存损坏 （memory corruption）"></a>7.1 第五章 <strong>内存损坏</strong> （memory corruption）</h3><p>“ 几乎所有的人都能忍受逆境，但如果你想测试一个人的人格，那就给他力量。” ——亚伯拉罕 林肯</p>
<h4 id="7-1-1-概述"><a href="#7-1-1-概述" class="headerlink" title="7.1.1 概述"></a>7.1.1 概述</h4><p>在本书中，你应该接受这样的假设，即任何内存损坏漏洞都是可以被利用来实施攻击的，除非你能证明它不成立。这个假设看起来很极端，但这对代码审计者来说非常有用。攻击者经常可以利用对越界的内存进行写操作来任意地改变一个进程的运行状态，  从而违反应用程序应该执行的任何安全策略。 然而，除非你对如利用内存损坏有一定了解，否则你很难接受内存损坏漏洞的严重性，甚至无法理解它们。</p>
<p>漏洞利用和软件审计是两种高度互补的技巧。一个审计者拥有对漏洞利用的理解能提高效率，并且发现那些无伤大雅的bug与真实漏洞的区别。关于内存损坏漏洞的知识有很多，本章会简要介绍在Intel x86架构下机器的一些基本方法（当然这些概念同样适用于所有架构）。顺着漏洞利用的方法，你可以学到更多关于反漏洞利用技术以及发现可利用之处的方法。本教程并不打算作为开发内存损坏漏洞的权威指南，但它确实提供了你需要了解和了解贯穿本书的许多漏洞的背景知识。 </p>
<h5 id="注"><a href="#注" class="headerlink" title="注"></a>注</h5><p>读者如果有兴趣了解更多关于利用内存损坏漏洞的知识，可以参考The Shellcoder’s Handbook  (Wiley, 2004))或  Exploiting Software(Addison-Wesley, 2004))。你还可以找到许多关于开发技术的在线资源，如  phrack magazine(<a href="http://www.phrack.org)和Uninformed" target="_blank" rel="noopener">www.phrack.org)和Uninformed</a> magazine(<a href="http://www.uninformed.org)。" target="_blank" rel="noopener">www.uninformed.org)。</a> </p>
<h4 id="7-1-2-缓冲区溢出"><a href="#7-1-2-缓冲区溢出" class="headerlink" title="7.1.2 缓冲区溢出"></a>7.1.2 缓冲区溢出</h4><p>你可能很熟悉“缓冲区溢出”（buffer overflow）这个术语，如果不是的话，下面是它的定义：<strong>缓冲区溢出</strong>是一种软件bug，它是当数据被复制到内存的某个位置但这段内存不足以容纳这些数据时产生的。当缓冲区溢出发生时，溢出的数据会破坏与目标缓冲区相邻的信息，并通常造成灾难性的后果。</p>
<p>缓冲区溢出是最常见的一种内存损坏漏洞。如果不你熟悉如何利用这种bug，它们似乎违背逻辑，以某种方式允许攻击者完全访问脆弱的系统。但的机制是如何的呢?为真么它是对系统一致性（system integrity）的一种威胁呢？ 为什么操作系统会保护一段内存不被损坏呢？为了回答这些问题，你需要对程序内部以及CPU和操作系统怎样管理进程有所熟悉。</p>
<h5 id="注-1"><a href="#注-1" class="headerlink" title="注"></a>注</h5><p>一些在本书种提到的漏洞严格来说并不是缓冲区溢出而是更加复杂的内存损坏漏洞，但它们都有很多共同特征。关于可利用性的讨论主要适用于这类问题，特别是在本章后面的小节“评估内存损坏影响”中。 </p>
<h5 id="进程的内存布局"><a href="#进程的内存布局" class="headerlink" title="进程的内存布局"></a>进程的内存布局</h5><p>一个进程可以被操作系统选择任意的方式布局在内存中，但几乎所有当下的系统都遵循了一些常见的约定。通常的，一个进程被组织在以下几个主要区域：</p>
<ul>
<li>程序代码区。这个区域包含了能被处理器解释并运行的可执行程序指令。程序代码包括了编译后的运行程序代码以及额外的被程序所使用的位于共享库的代码。共享库通常不和主程序的代码放在一起。</li>
<li>程序数据区。这个区域储存了非函数本地的变量。包括了全局和静态变量。数据区通常包含了一个动态内存区域称为“程序堆”（program heap）用来储存动态分配内存的变量。</li>
<li>程序栈区。栈（stack）区用来存储当前正在执行的函数，并且它在函数执行时跟踪函数的调用链。 </li>
</ul>
<p>尽管这是个关于进程内存如何组织的高级视角，但它也显示了缓冲区溢出漏洞的影响如何根据缓冲区的位置而变化。下面几节讨论与每个位置相关的常见和惟一的攻击模式。 </p>
<h5 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h5><p>栈溢出（stack overflow）是一种目标缓冲区位于运行中程序栈的缓冲区漏洞。它们是最容易理解，并且在历史上是最直接的可以利用的缓冲区溢出。本节涵盖了关于运行中程序栈的基础知识，然后显示攻击者是怎样利用基于栈的缓冲区溢出的。</p>
<h6 id="抽象数据类型：栈"><a href="#抽象数据类型：栈" class="headerlink" title="抽象数据类型：栈"></a>抽象数据类型：栈</h6><p>从一般的计算机科学视角来看，栈是一种抽象数据类型（abstract data type，ADT），它用来有序存储和检索一系列数据元素。 栈数据结构通常会给用户提供两种用来控制的操作：</p>
<ul>
<li><code>push()</code>push操作添加一个元素到栈的顶端</li>
<li><code>pop()</code> pop操作将栈顶元素移除，并将其作为返回值；</li>
</ul>
<p>栈是一个后进先出（last-in， first-out LIFO）的数据结构，你可以将它看成一个物理的盘子的堆栈。你可以将一个盘子放在栈的顶端，相当于<code>push()</code>操作，你也可以将顶端的盘子拿走，对应<code>pop()</code>操作。你不能在移出上面的盘子之前直接从栈的中间拿走一个盘子。</p>
<h6 id="运行时栈"><a href="#运行时栈" class="headerlink" title="运行时栈"></a>运行时栈</h6><p>每个进程都有运行时栈（runtime stack），也叫做程序栈（program stack），调用栈（call stack），或者直接称它为“栈”。运行时栈为每种结构化编程语言中使用的函数提供了必要的基础。 函数可以用任意的顺序调用，它们可以是递归的，也可以是相互递归的。运行中的栈通过激活记录（activation record）支持这个功能，激活记录也就是记录了从函数到函数的调用链以便在函数返回时跟踪它们。激活记录当然也包含了每次函数调用时需要分配的数据，例如局部变量，存储的机器状态以及函数参数。</p>
<p>因为运行时栈是程序运行不可分割的一部分 ，因此它们在CPU的帮助下实现而不是通过纯净的软件抽象。处理器通常有专门用来指向栈顶的寄存器，这些寄存器用机器指令<code>push()</code>和<code>pop()</code>来对栈进行修改。在因特尔x86 CPU中，这个指针叫ESP（ESP表示扩展堆栈指针，extended stack pointer）。</p>
<p>在几乎所有现代CPU中，栈都是向下生长的，也就是说栈通常在虚拟内存的一个高地址开始，然后顺着低地址生长。一个<code>push</code>操作让栈指针减去固定值，然后栈指针就移动到了更低的进程内存。相应的，<code>pop</code>操作让栈指针加一个固定值将它移动到更高位置的内存。</p>
<p>每当函数被调用时，程序都会创建一个新的栈区， 它只是一个保留的连续内存块，用于存储本地变量和内部状态信息。 函数在它返回之前就使用这一段内存，在返回之后，它会被移出栈。为了了解这个过程，考虑以下程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">function_B</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    </span><br><span class="line">    x = a * a;</span><br><span class="line">    y = b * b;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (x+y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">function_A</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line">c = p * q * function_B(p, p);</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line">ret = function_A(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当<code>function_A()</code>调用时，一个新的栈会被分配出来然后放置在堆栈的顶部，如图5-1所示。</p>
<p>这张图只是程序栈的一个简化版本，但你可以看到<code>main()</code>函数栈的布局中调用了<code>function_A()</code>.</p>
<p><img src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/the_art_of_security_assessment_translate/5-1.png" alt="5-1"></p>
<h6 id="注-2"><a href="#注-2" class="headerlink" title="注"></a>注</h6><p>图5-1和图5-2第一眼看起来可能会让你感到困惑，因为栈似乎是从上往下生长的，然而这并不错。如果你想象一个从地址0到0xFFFFFFFF的内存地址空间，低地址接近于0，因此在图中就是比较高的地方。</p>
<p><img src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/the_art_of_security_assessment_translate/5-2.png" alt="WeChat Screenshot_20200512175525"></p>
<p>图5-2显示了当<code>function_A()</code>调用<code>function_B()</code>时程序栈会变成的样子。</p>
<p>当<code>function_B()</code>运行完毕后会返回到<code>function_A()</code>,于是<code>function_B()</code>对应的这一栈段就会出栈，然后程序栈会重新像图5-1那样，简单来说就是寄存器ESP储存的值会被重置回当<code>function_B()</code>调用时。</p>
<h6 id="注-3"><a href="#注-3" class="headerlink" title="注"></a>注</h6><p>5-1和5-2的栈图是简化版的。事实上，<code>main()</code>函数不是调用栈的第一个函数。通常，函数会在<code>main()</code>函数设置进程环境时就被调用。例如，gibic Linux系统通常以名为<code>_start()</code>的函数开始，它会调用<code>_libc_start_main()</code>，然后这个函数最后再调用<code>main()</code>。</p>
<p>每个函数都管理着属于自己的栈段，这些栈段取决于有多少局部变量在函数中以及这些局部变量的大小。局部变量需要当函数需要时被直接访问，如果只使用push和pop指令则效率会不高。因此，很多程序会利用其他的寄存器来完成这些事，它们叫帧指针(frame pointer)或者基址指针(base pointer)。在Intel x86 CPU中，这个寄存器名字叫EBP(extended base pointer)。这个寄存器指向函数栈段的起始点。每个在给定栈段中的变量都可以通过引用基址指针开始的固定偏移量的内存位置被访问。对基址指针的使用并不是必要的，有时候甚至是多余的，当然为了讨论它，我们可以假设它是存在的。</p>
<p>前面忽略的一个重要细节是记录在每个栈段中的内部状态信息。状态信息的存储随着处理器架构的不同而不同。但它通常包含了先前函数段的指针以及返回地址。这个返回地址的值被保存过了，所以当当前运行函数运行完毕返回时，CPU就会知道当前运行程序应该从哪里继续。当然，帧指针的值必须恢复，以便在函数调用分配其自身栈段的子函数之后，局部变量的访问能保持一致。</p>
<h6 id="函数调用约定"><a href="#函数调用约定" class="headerlink" title="函数调用约定"></a>函数调用约定</h6><p>调用约定(calling convention)描述了函数参数时怎样传入以及调用和被调用的函数必须执行哪些栈的操作。 在本章前面一节“运行时栈”中说明了最流行的一种调用约定，然而调用约定会随着处理器架构，操作系统，编译器的不同而不同。</p>
<p>编译器可以通过优化来改变调用约定。例如，一种流行的 x86 调用约定叫快速调用(fast call)。如果可能，快速调用会将函数参数传入寄存器，这样可以提高变量访问的速度以及减少栈上的操作。每个编译器都有不同版本的快速调用。</p>
<p>语言特性也可以造成不同的调用约定。一个典型的例子就是要求访问类实例的<code>this</code>指针的C++类成员函数。在windows x86系统中，<code>this</code>指针会被传入ECX寄存器中传递给具有固定数量参数的函数。相反，在GCC C++编译器中会将<code>this</code>指针当作函数最后一个变量将它push到栈中。</p>
<p>栈指针也必须被恢复到它以前的状态，但这个过程不是隐式的，被调用的函数必须在返回前重置栈指针到正确的位置。这个过程时必须的，因为储存的帧指针以及返回的地址会从栈顶被恢复。通过使用隐式使用栈指针的<code>pop</code>指令，帧指针能够被恢复。用于从函数返回的<code>ret</code>指令也隐式地使用ESP寄存器获取返回地址。</p>
<p>每个函数会分配自己的栈段，因此，它们需储存自己的段指针。下面这段代码显示了在Intel机器中函数在开头是怎样储存自己的栈段指针的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">text:5B891A50		mov edi, edi</span><br><span class="line">text:5B891A52 		push ebp</span><br><span class="line">text:5B891A53		mov ebp, esp</span><br></pre></td></tr></table></figure>

<p>这段函数开头的代码并不要求调用者具体地将返回地址push到栈中，这个过程会被<code>call</code>指令完成。因此当<code>function_B()</code>被调用时栈地布局会如图5-3所示。</p>
<p><img src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/the_art_of_security_assessment_translate/5-3.png" alt="5-3"></p>
<h6 id="注-4"><a href="#注-4" class="headerlink" title="注"></a>注</h6><p>你可能注意到了在上面那段代码中一个看起来没有用的指令<code>(mov edi, edi)</code>。这个指令只是一个占位符，添加它时为了简化系统监视和debug。</p>
<h5 id="利用栈溢出"><a href="#利用栈溢出" class="headerlink" title="利用栈溢出"></a>利用栈溢出</h5><p>如你所见，局部变量非常接近彼此。事实上，它们被安排在了连续的内存中。因此如果一个程序有这样一个漏洞，它允许数据将数据写入到本地栈缓冲区末尾之后的地方，那么与数据相邻的变量就会被重写。这些相邻的变量可以包括其他的局部变量，程序状态信息，甚至函数参数。取决于有多少个字节能够被写入，攻击者能够在前面的栈段中损坏变量以及状态信息。</p>
<h6 id="注-5"><a href="#注-5" class="headerlink" title="注"></a>注</h6><p>编译器有时会在一个变量和下一个变量之间添加填充，这取决于优化级别异界变量大小等多个因素。出于讨论目的，可以将变量视为连续的。</p>
<p>我们来考虑一个简单的写入覆盖局部变量的情况。写入一个局部变量的危险性就是你可以任意更改一个应用不想让你更改的变量的值。状态的变化通常也可以造成你不想要的后果。考虑以下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">authenticate</span><span class="params">(<span class="keyword">char</span> *username, <span class="keyword">char</span> *password)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> authenticated;</span><br><span class="line"><span class="keyword">char</span> <span class="built_in">buffer</span>[<span class="number">1024</span>];</span><br><span class="line">authenticated = verify_password(username, password);</span><br><span class="line"><span class="keyword">if</span>(authenticated == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">sprintf</span>(<span class="built_in">buffer</span>,</span><br><span class="line"><span class="string">"password is incorrect for user %s\n"</span>,</span><br><span class="line">username);</span><br><span class="line"><span class="built_in">log</span>(<span class="string">"%s"</span>, <span class="built_in">buffer</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> authenticated;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设用来验证的变量位于栈段的顶部，将其放置在比buffer变量更高的内存位置。函数栈就像图5-4那样</p>
<p><img src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/the_art_of_security_assessment_translate/5-4.png" alt="5-4"></p>
<h6 id="注-6"><a href="#注-6" class="headerlink" title="注"></a>注</h6><p>图5-4展现了代码可能的布局。然而你不能从源代码中推断出变量在栈段中是怎样分布的。为了优化性能，编译器可以（通常也会这样做）重新布局变量。</p>
<p><code>authenticate()</code>函数有缓冲区溢出的漏洞。具体来说，<code>printf()</code>函数没有规定它写入输出缓冲区数据的多少。因此，如果一个<code>username</code>字符串大约在1024字节大小的话，数据将写入缓冲区变量的末尾之后，并写入变量<code>authenticate</code>。（注意<code>authenticated()</code>在栈的顶部）。图5-5显示了当溢出触发时会发生什么</p>
<p><img src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/the_art_of_security_assessment_translate/5-5.png" alt="5-5"></p>
<p><code>authenticated</code>是一个简单的状态变量，用来表示用户是否能够成功登陆。0值表示验证失败，非0值表示成功。通过溢出缓冲区的变量，攻击者可以重写<code>authenticated</code>变量，然后让它变成非0值，于是调用函数不正确地将攻击者当作了验证成功。</p>
<p>重写相邻地局部变量是一个很有用的技巧，但一般来说它很难应用。这种技巧取决于什么样的变量能够被重写，编译器如何在内存中安排变量，以及程序在溢出发生后会做什么。一个更一般性的技巧是定位到每个栈帧保存的状态信息，即保存的帧指针以及返回地址。对于这两个变量来说，返回地址对于攻击者来说是最重要的。如果缓冲区溢出能够重写保存的返回地址，应用程序就可以在当前运行函数返回时重定位到任意的位置，这个过程见图5-6：</p>
<p><img src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/the_art_of_security_assessment_translate/5-6.png" alt="5-6"></p>
<p>本质上说，攻击者会在程序中保存一些对他们有用的代码的地址，并用这个新地址覆盖返回地址。确切的位置取决于攻击者，但有两种比较基本的选择：</p>
<ul>
<li>运行程序可以被重定位到应用程序运行的代码段或者一些在可以利用的分享库中的代码。例如，在UNIX libc里的<code>system()</code>函数，这个函数通过shell来运行命令。</li>
<li>运行程序可以被重定位到一个包括了攻击者控制数据的内存区域，例如全局变量，一个栈的位置，或者一个静态的缓冲区。在这种情况下， 攻击者用一小段与位置无关的代码填充目标返回位置，以完成一些有用的工作，例如连接回攻击者并在连接的套接字上生成shell。 这些小段的代码通常被称为shellcode.</li>
</ul>
<h5 id="SEH-攻击"><a href="#SEH-攻击" class="headerlink" title="SEH 攻击"></a>SEH 攻击</h5><p> Windows系统很容易受到与传统堆栈溢出攻击稍有不同的攻击，这种变体称为 “销毁结构化异常处理程序”。 Windows提供了结构化异常处理( structured exception handling, SEH)，因此成语可以注册一个处理程序，以一致的方式处理错误。当一个线程导致了一个异常抛出，这个线程就有机会捕获异常并进行恢复。每当一个函数注册异常处理程序时， 它都被放在当前注册的异常处理程序链的顶部。 当异常抛出时，这个程序链就会从顶部遍历，直到为抛出的异常找到正确的处理程序类型为止。如果没有找到合适的异常处理程序，异常就会被送到一个“未处理的异常过滤器”（unhandled exception filter），这个过滤器一般会终止该进程。</p>
<h5 id="注-7"><a href="#注-7" class="headerlink" title="注"></a>注</h5><p>异常处理时许多程序拥有的特性并且是由C++推广而来的。尽管C++的异常处理比基础的Windows SEH机制更复杂，但C++异常在Windows中是通过SEH来实现的。如果想了解更多关于C++异常处理的内容，请查看该链接：  <a href="http://www.openrce.org/articles/full_view/21" target="_blank" rel="noopener">www.openrce.org/articles/full_view/21</a>.</p>
<p>SEH提供了一个便利的方法来利用Windows系统的栈溢出实施攻击，因为异常处理程序注册结构就位于栈中。每个结构都由例行注册程序(handler routine)的地址以及一个指针指向它的父注册程序。这种结构见图5-7(其实就是一个链表 – By 译者)：</p>
<p><img src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/the_art_of_security_assessment_translate/5-7.png" alt="5-7"></p>
<p>当异常发生时，这些记录将从最近注册的处理程序遍历到第一个处理程序。在每一层中，处理程序都运行决定当前抛出的异常是否合适。（这个说明有点过于简化了，但有一篇很好的文章描述了这一过程，见：  <a href="http://www.microsoft.com/msj/0197/exception/exception.aspx.）因此，如果攻击者能够通过任何方法触发溢出，然后触发任何类型的异常，检查这些异常注册结构时，异常处理程序会定位到每个调用的结构直到找到其中合适的哪一个。因为它们是被攻击者损坏过的栈，程序就会跳转到攻击者选择的地址。当能够造成大量数据溢出缓冲区时，攻击者就可以复制整个栈区，在栈基指针被修改时导致异常抛出。然后应用程序在栈上使用被损坏的SEH信息然后跳跃到任意地址，这个过程见图5-8：" target="_blank" rel="noopener">www.microsoft.com/msj/0197/exception/exception.aspx.）因此，如果攻击者能够通过任何方法触发溢出，然后触发任何类型的异常，检查这些异常注册结构时，异常处理程序会定位到每个调用的结构直到找到其中合适的哪一个。因为它们是被攻击者损坏过的栈，程序就会跳转到攻击者选择的地址。当能够造成大量数据溢出缓冲区时，攻击者就可以复制整个栈区，在栈基指针被修改时导致异常抛出。然后应用程序在栈上使用被损坏的SEH信息然后跳跃到任意地址，这个过程见图5-8：</a></p>
<p><img src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/the_art_of_security_assessment_translate/5-8.png" alt="5-8"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/05/the-art-of-software-security-assessment-Chap2-translate/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chenyu ZHU">
      <meta itemprop="description" content="Chenyu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chenyu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/05/the-art-of-software-security-assessment-Chap2-translate/" class="post-title-link" itemprop="url">the art of software security assessment Chap2. translate</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-05 23:08:52" itemprop="dateCreated datePublished" datetime="2020-06-05T23:08:52+08:00">2020-06-05</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="第二章-设计审查"><a href="#第二章-设计审查" class="headerlink" title="第二章 设计审查"></a>第二章 设计审查</h3><p>“确实如此，我们每个人背上都背着一个未经许可的核动力加速器，没什么大问题。”</p>
<p>——  Bill Murray在捉鬼敢死队（1984）中饰演Peter Venkman时所说</p>
<h4 id="6-2-1-导言"><a href="#6-2-1-导言" class="headerlink" title="6.2.1 导言"></a>6.2.1 导言</h4><p> 在设计审查(design review)方面，计算机安全人员往往分为两大阵营。具有正式开发背景的人通常能够接受设计审查过程。这是很自然的，因为它与大多数正式的软件开发方法密切相关。设计审查过程似乎也比手工审查大型应用程序代码库更省事。 </p>
<p> 另一派是代码审计员，他们乐于发现最模糊、最复杂的漏洞。这群人倾向于将设计审查看作是一个象牙塔结构，只是妨碍了真正的工作。设计评审的形式化过程和对文档的关注成为深入研究代码的障碍。 </p>
<p>事实是，设计审查(的价值)介于这两个阵营的观点之间，它对两者都有价值。设计审查是一个有用的工具，用于识别应用程序体系结构中的漏洞，并为实现审查(implementation review)确定组件的优先级。然而，它并没有取代实现审查;这只是整个审查过程的一部分。它使识别设计缺陷变得容易得多，并提供了对软件设计安全性的更全面的分析。在这种情况下，它可以使整个审查过程更有效，并确保你在投入的时间中获得最佳回报。 </p>
<p>本章介绍了一些软件设计和设计漏洞的背景知识，并介绍了一个审查过程，以帮助你确定软件设计中的安全问题。 </p>
<h4 id="6-2-2-软件设计基础"><a href="#6-2-2-软件设计基础" class="headerlink" title="6.2.2 软件设计基础"></a>6.2.2 软件设计基础</h4><p>在进入设计审查这个课题之前，我们先来回顾一下一些关于软件设计的基础。许多关于软件设计的概念在这章中与安全息息相关，特别是在威胁建模中（threat modeling）。以下几个小节介绍了学习设计安全所必要的关于软件设计的概念：</p>
<h5 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h5><p>软件工程归根结底可以认为是开发和实现算法的过程。从设计的角度来看，这个过程着重于开发关键的程序算法和数据结构，以及指定问题域逻辑。要了解系统设计的安全需求和漏洞潜力，你必须首先了解组成系统的核心算法。 </p>
<h6 id="问题域逻辑"><a href="#问题域逻辑" class="headerlink" title="问题域逻辑"></a>问题域逻辑</h6><p>问题域逻辑（Problem Domain Logic），或者业务逻辑（Business Logic） 提供了程序在处理数据时遵循的规则。  软件系统的设计必须包括软件执行的主要任务的规则和过程。软件设计的一个主要组成部分是与系统用户和资源相关的安全预期。例如，考虑具有以下规则的银行软件:</p>
<ul>
<li>一个人可以从他/她的主要账户到任何其它合法账户中转账</li>
<li>一个人可以从他/她的市场账户（market account）到任何合法账户中转账。</li>
<li>一个人每个月只能从他/她的市场账户转一次账。</li>
<li>如果一个人在他/她的主要账户上的余额低于零，钱就会自动从他/她的市场账户转出，以抵消低于零的部分(如果这些钱足够的话)。 </li>
</ul>
<p>这个例子很简单，但是你可以看到，银行客户可能能够绕过市场帐户每月一次的转账限制。他们可以故意将自己的主要账户的资金取到余额低于0。因此，该系统的设计存在一个漏洞，银行客户可能会利用这个漏洞。 </p>
<h6 id="核心算法"><a href="#核心算法" class="headerlink" title="核心算法"></a>核心算法</h6><p>通常，程序的性能要求决定了用于管理关键数据段的算法和数据结构的选择。有时可以从设计的角度评估这些算法的选择，并预测可能影响系统的安全漏洞。 </p>
<p>例如，假如你知道一个程序将传入的一系列记录存储在支持基本顺序搜索的已排序链表中。基于这一知识可以预见的是，一个特别精心制作的庞大记录列表可能会导致程序花费大量时间在链表中进行搜索。对这样的关键算法的重复集中攻击很容易导致服务器功能的暂时甚至永久中断。</p>
<h5 id="抽象与分解"><a href="#抽象与分解" class="headerlink" title="抽象与分解"></a>抽象与分解</h5><p>软件设计的每个地方都不可避免地包含两个基本概念:抽象和分解。你可能已经熟悉了这些概念，但如果还不熟悉，下面的段落将提供一个简要的概述。 </p>
<p><strong>抽象</strong>(abstraction)是一种降低系统复杂性、使其更易于管理的方法。要做到抽象，只需要隔离最重要的元素并删除不必要的细节。抽象是人们感知周围世界的重要部分。他们解释了为什么你可以看到一个符号😊，就把它与一个微笑的脸联系起来。抽象允许你概括一个概念，例如面孔，以及其他相关的概念，例如微笑的面孔和皱眉的面孔。</p>
<p>在软件设计中，抽象是对应用程序将执行的流程进行建模的方式。它们使你能够建立相关系统、概念和流程的层次结构，从而隔离问题域逻辑和关键算法。实际上，设计过程只是构建一组抽象的方法，你可以通过开发过程实现它们。当一个软件必须解决一系列用户所关心的问题，或者它的实现必须分布在一个开发团队中时，这个过程变得特别重要。 </p>
<p><strong>分解</strong>(decopmesiton)，或因式分解(factoring)是定义组成抽象的泛化(generalization)和分类的过程。分解可以在两个不同的方向运行。自顶向下的分解，即所谓的专门化，是将一个较大的系统分解成更小、更易于管理的部分的过程。自底向上的分解，称为泛化，涉及到识别许多组件中的相似性，并开发一个应用于所有组件的更高层次的抽象。 </p>
<p>结构化软件分解的基本元素可能因语言的不同而不同。标准的自顶向下进展是应用程序、模块、类和函数(或方法)。有些语言可能不支持列表中的所有区别(例如，C语言不支持类);其他语言添加了更多的区别或使用略有不同的术语。 对于我们作设计审查的目的而言，这些差异并不重要，但是为了简单起见，本文主要讨论模块和函数。</p>
<h5 id="信任关系"><a href="#信任关系" class="headerlink" title="信任关系"></a>信任关系</h5><p>在第一章软件漏洞基础中，我们已经介绍了关于信任以及它是如何影响系统的全的。 本章对这一概念进行了扩展，指出多方之间的每一次通信都必须具有一定程度的信任。有一个术语叫<strong>信任关系</strong>（trust relationship）可以表述它。对于简单的通讯，两个群体都可以假设对另一方完全信任，也就是每个通讯群体都允许其他群体在参与通信时对暴露的功能拥有完全访问权限。然而，你更关心的时通信双方应该限制彼此信任的情况，这意味着各方只能访问到彼此功能的有限子集。通信的每一方施加的限制定义了他们之间的信任边界(trust boundary)。信任边界区分了信任共享的区域，称为<strong>信任域</strong>（trust domains）。如果你对这些概念有点迷惑，无需担心，下一节将提供一些示例。</p>
<p>软件设计需要考虑系统的信任域、边界和关系;<strong>信任模型</strong>（trust model）是表示这些概念的抽象，是应用程序安全政策的一个组件。此模型的影响在系统如何分解上很明显，因为信任边界也往往是模块边界。模型通常要求信任不是绝对的;相反，它支持被称为特权的不同程度的信任。一个典型的例子是标准的UNIX文件权限，用户可以为系统上的其他用户提供有限的文件访问权限。具体来说，用户可以指定是否允许其他用户读取、写入或执行文件(或这些权限的任何组合)，从而将有限的信任扩展到系统的其他用户。 </p>
<h6 id="简单的信任边界"><a href="#简单的信任边界" class="headerlink" title="简单的信任边界"></a>简单的信任边界</h6><p>举一个简单的信任边界例子。考虑一个简单的单用户操作系统，比如Windows 98.为了使这和例子简单化，我们不考虑关于网络的部分。Win 98有简单的内存保护机制以及一些关于用户的概念，但它没有提供访问控制或者执行的措施。也就是说，如果用户可以登陆Win 98的系统，他就可以任意更改文件或者系统设定。因此，对于能够登陆上Win 98的交互性用户而言就不存在什么安全性。</p>
<p>你可以认为对于交互性的用户之间，（没有联网的）Win 98系统没有提供信任边界。然而你可以作这样的假设，即什么人可以物理访问这个系统。所以你可以说信任边界就在这种情况下定义了，即在能够拥有物理访问权限的用户和没有权限的用户。（<em>这段有点拗口，用大白话说就是能摸到这台电脑的人和摸不到这台电脑的人之间有信任边界 –by 译者</em>） 这样就只剩下一个由受信任用户组成的域和一个表示所有不受信任用户的隐式域。 </p>
<p>让这个例子变得复杂一点，现在我们升级到多用户操作系统，比如Win XP专业版。现在我们就要考虑更多了。你可以想象两个拥有一般权限的用户不可以更改彼此的数据或者进程，当然，这个假设建立在你不是管理员用户（administrative user）的情况下。所以现在两个用户在系统中拥有了保密性以及完整性，这种保密性与完整系就构成了彼此的信任边界。当然由于管理员用户的存在我们也要假如其他的边界：非管理员用户无法影响到系统的完整性以及设置。这种边界是自然的，强加给用户之间的界限是必须的，毕竟如果任何用户都能影响到系统的状态，那就是单用户操作系统没什么不同了。下面是一个多用户操作系统的信任关系的图例：</p>
<p><img src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/the_art_of_security_assessment_translate/2-1.png" alt="2-1"></p>
<p>现在退一步考虑信任的本质。也就是说，每个系统最终都必须有一些绝对可信的权威。没有办法，因为必须有人对系统的状态负责。这就是为什么UNIX有一个root帐户，而Windows有一个管理员帐户。当然，你可以对这个级别的权限给与一系列的控件。例如，UNIX和Windows都有向不同用户授予不同程度的管理特权的方法。然而，一个简单的事实仍然是，在每个信任边界中，至少有一个可以承担责任的绝对权威(<em>也就是至少有一个边界时由root 与非 root来划分的 ——by译者</em>)。</p>
<h6 id="复杂的信任关系"><a href="#复杂的信任关系" class="headerlink" title="复杂的信任关系"></a>复杂的信任关系</h6><p>到目前为止，了解稍后需要处理的问题领域，你已经了解了相当简单的信任关系。然而，一些更详细的细节被忽略了。为了使讨论更实际一些，我们考虑连接到网络的同一个系统。 </p>
<p>将系统连接到网络后，必须开始添加一系列区分。你可能需要为系统的本地用户和远程用户考虑单独的域，并且你可能需要 能够通过网络访问系统但不是“常规”用户的人提供域。  防火墙和网关进一步使这些区别复杂化，并引入了更多的区分。 </p>
<p>很明显，定义和应用信任模型对任何软件设计都有巨大的影响。真正的工作在设计过程开始之前就开始了。可行性研究和需求收集阶段必须充分确定和定义用户的安全期望和目标环境的相关因素。生成的模型必须有足够的鲁棒性，以满足这些需求，但又不能复杂到难以实现和应用。这样，安全性就必须小心地平衡清楚性和准确性的需要。在本章后面的部分中，当研究威胁建模时，你将通过评估不同系统组件之间的边界和系统上不同实体的权限来考虑信任模型。 </p>
<h6 id="信任链"><a href="#信任链" class="headerlink" title="信任链"></a>信任链</h6><p>第一章介绍过了信任传递的观点，本质上说，信任传递就是如果组件A信任组件B，那么A就必须信任组件B所信任的所有组件。这个概念也可以称为信任链（chain of trust）关系。</p>
<p>信任链是一个完全可行的安全构造，也是许多系统的核心。考虑证书在到Web服务器的典型安全套接层协议(Secure Sockets Layer, SSL)连接中分发和验证的方式。你有一个本地签名数据库，用于标识你信任的提供者。然后，这些提供者可以向证书颁发机构(certificate authority CA)颁发证书，然后CA可以扩展到其他颁发机构。最后，托管站点的证书由这些机构之一签署。在建立SSL连接时，必须遵循从一个CA到另一个CA的信任链。 只有当到达可信数据库中的某个权限时，遍历才会成功。 </p>
<p>现在，假设你想要模拟一个Web站点，以达到某种邪恶的目的。目前，不考虑域名系统(Domain Name System， DNS)，因为它通常是一个容易的目标。相反，你所要做的就是找到一种方法来操作信任链中任何位置的证书数据库。这包括操作访客的客户端证书数据库、直接危害目标站点、或操作链中的任何CA数据库(包括根CA)。 </p>
<p>为了确保重点明确，重复最后一部分更好一些。每个CA共享的信任的传递性意味着任何CA安全性弱的部分都允许攻击者利用然后成功地模拟任何站点。颁发实际证书的CA是否受到威胁并不重要，因为由有效的CA颁发的任何证书就足够了。这意味着任何SSL事务的完整性只取决于最弱的CA。不幸的是，此方法是用于建立主机标识的最佳方法。 有些系统只能通过使用可传递的信任链来实现。但是，作为一名审计人员，你需要仔细研究选择这种信任模型的影响，并确定信任链是否合适。你还需要遵循所有包含组件的信任关系，并确定任何组件的实际公开程度。你经常会发现，使用信任链的结果是造成复杂而微妙的信任关系，攻击者可以利用这些关系。 </p>
<h6 id="纵深防御"><a href="#纵深防御" class="headerlink" title="纵深防御"></a>纵深防御</h6><p>纵深防御（defense in depth）就是分层保护，这样系统如果一个地方有弱点那这个弱点就能被其他控制手段减轻。纵深防御的简单示例包括使用低权限用户运行服务和守护进程，以及将不同的功能隔离到不同的硬件上，更复杂的例子包括网络非军事区(network demilitarized zones， DMZs)、  chroot jails以及栈(stack)和堆(heap)保护。 </p>
<p>当你为审查的组件划分优先级时，应当考虑分层防御。你可以能会将较低优先级分配给在低权限用户上运行的面向内部网的组件，该组件位于chroot jail中，并使用缓冲区保护进行编译。相反，你可能会为必须以root身份运行的面向因特网的组件分配更高级的优先级。这并不是说第一格组件时安全的，第二个不是。优先化威胁（prioritizing threat）将会在本章后面的“威胁建模”中详细讨论。</p>
<h5 id="软件设计的原则"><a href="#软件设计的原则" class="headerlink" title="软件设计的原则"></a>软件设计的原则</h5><p>软件开发方法的数量似乎与软件开发人员的数量成正比。不同的方法适合不同的需求，项目的选择也因各种因素而异。幸运的是，每种方法都有一些公认的原则。准确性（accuracy）、清晰性（clarity）、松散耦合（loose coupling）和强内聚性（strong coherence）这四个核心原则适用于每个软件设计，是讨论设计如何影响安全性的良好起点。 </p>
<h6 id="准确性"><a href="#准确性" class="headerlink" title="准确性"></a>准确性</h6><p>准确性也就是一个设计抽象是怎样高效地来符合需求的。准确性包括了一个抽象对需求如何准确地建模，还包含了它们怎样被合理地实现。 当然，我们的目标是用最直接的实现方法提供最精确的模型。</p>
<p> 在实践中，软件设计可能不会准确地转换为实现。在需求收集阶段的疏忽可能导致设计遗漏了重要的功能或强调了错误的关注点。设计过程中的失败可能会导致实现必然与设计产生巨大的差异，以满足实际的需求。即使流程中没有失败，预期和需求也会在实现阶段发生变化。所有这些问题都可能导致实现偏离预期的(和文档化的)设计。 </p>
<p>软件设计及其实现之间的差异导致了设计抽象中弱点的出现。这些弱点是滋生各种漏洞的温床，包括安全漏洞。它们迫使开发人员在预期的设计之外做出假设，而未能传达这些假设通常会造成易受攻击的情况。注意设计没有充分定义的地方，或者对程序员有不合理的期望。 </p>
<h6 id="清晰性"><a href="#清晰性" class="headerlink" title="清晰性"></a>清晰性</h6><p>软件设计可以为极其复杂且常常令人困惑的过程建模。为了达到清晰的目的，一个好的设计应该以一种合理的方式分解问题，并提供清晰、不证自明的抽象。结构的文档也应该很容易获得，并且参与实现过程的所有开发人员都应该很好地理解它。 </p>
<p>不必要的复杂或文档记录不良的设计可能导致类似于不准确设计的漏洞。在这种情况下，抽象中的弱点会出现，因为对于精确的实现来说，对设计的理解太不到位了。你的审查应该识别出没有充分文档化或异常复杂的设计组件。你可以在整本书中看到这个问题的例子，特别是在第7章，“程序构建块”。 </p>
<h6 id="弱耦合性"><a href="#弱耦合性" class="headerlink" title="弱耦合性"></a>弱耦合性</h6><p>耦合是指模块之间的通信级别以及模块之间相互公开内部接口的程度。松散耦合的模块通过定义良好的公共接口交换数据，这通常会导致更具适应性和可维护性的设计。相反，强耦合模块具有复杂的相互依赖关系，并公开其内部接口的重要元素。 </p>
<p>强耦合模块通常彼此高度信任，很少为它们的通信执行数据验证。在这些通信中缺少定义良好的接口也使数据验证变得困难和容易出错。当其中一个组件可被攻击者控制时，这往往会导致安全缺陷。从安全的角度来看，您需要寻找任何跨信任边界的强模块间耦合。 </p>
<h6 id="强内聚性"><a href="#强内聚性" class="headerlink" title="强内聚性"></a>强内聚性</h6><p>内聚是指模块的内部一致性。这种一致性主要是模块的接口处理一组相关活动的程度。强内聚性鼓励模块只处理紧密相关的活动。保持强内聚的一个副作用是，它倾向于鼓励强内部耦合(单个模块的不同组件之间的耦合程度)。 </p>
<p>当设计无法沿着信任边界分解模块时，可能会出现内聚相关的安全漏洞。由此产生的漏洞类似于强耦合问题，只不过它们发生在同一个模块中。这通常是系统在设计的早期阶段没有考虑安全性的结果。要特别注意在单个模块中处理多个信任域的设计。 </p>
<h5 id="基础的设计缺陷"><a href="#基础的设计缺陷" class="headerlink" title="基础的设计缺陷"></a>基础的设计缺陷</h5><p>现在你已经有了基本的理解，可以考虑一些基本设计概念如何影响安全性的示例。特别是，你需要了解误用这些概念会如何造成安全漏洞。在阅读下面的例子时，你会很快注意到它们往往是由一系列问题导致的。通常，一个错误是可解释的，并且很大程度上取决于审查者的观点。不幸的是，这是设计缺陷的一部分。它们通常在概念级别上影响系统，并且很难进行分类。相反，你需要关注问题的安全影响，而不是陷入分类中。 </p>
<h6 id="强耦合利用"><a href="#强耦合利用" class="headerlink" title="强耦合利用"></a>强耦合利用</h6><p>本节将探索一个基本的设计缺陷，该缺陷是由于未能沿着信任边界正确分解应用程序而导致的。这些被称为粉碎漏洞（Shatter class of vulnerabilities），最初报告的独立研究的一部分由克里斯佩吉特进行。特定的攻击方式利用了Windows GUI应用程序编程接口(API)的某些属性。下面的讨论避免了许多细节，以突出设计的具体性质的粉碎漏洞。第十二章，“Windows II:进程间通信”提供了与这类漏洞相关的技术细节的更深入的讨论。 </p>
<p>Windows程序使用消息系统（messaging system）来处理所有和GUI相关的事件，每个桌面都有一个消息队列，用于与之关联的所有应用程序。所以任意两个进程在同一个桌面上运行时都可以向彼此发送消息， 不管流程的用户上下文是什么。 这就会造成一个问题，即高权限的进程，例如服务进程，在普通用户的桌面上运行。</p>
<p>Windows API提供了 <code>SetTimer()</code>函数来为发送<code>WM_TIMER</code>消息安排时间。这个消息可以内含一个指向函数的指针，这个函数在当默认消息句柄（message handler）收到<code>WM_TIMER</code>调用。这就会造成一种情况，一个进程可以控制同一个桌面上运行的任何其他进程的函数的调用。 攻击者惟一关心的是如何为目标进程的执行提供代码。 </p>
<p>Windows API包含了很多的消息用来更改窗口元素，通常，它们是用来设定文本框内容以及标签，更改剪贴板的内容。然而，攻击者可以利用这些消息从目标进程的地址空间出插入数据。将这些数据和<code>WM_TIMER</code>结合起来之后，攻击者可以在相同桌面的任何进程部署和运行任何代码。这就是一个权限升级漏洞，可以用于攻击在交互式桌面上运行的服务。</p>
<p>当这个漏洞发表后，微软更改了<code>WM_TIMER</code>消息的处理方法。核心问题就是，跨桌面的通信必须被视为潜在的攻击载体。 当你考虑到最初的消息传递设计受到单用户操作系统很大的影响时，这就更有意义了。在这种情况下，这样的设计就是准确的，清晰的，有强内聚性的。（<em>即最初的消息传递机制就是为单用户操作系统设计的，这不影响到软件设计的三大原则，但扩展到多用户操作系统这就是一个漏洞了——by 译者</em>）</p>
<p>此漏洞说明了为何难以将安全性添加到现有设计中。最初的Windows消息传递设计对于它的环境来说是合理的，但是引入了一个多用户操作系统改变了这种情况。消息传递队列现在在同一个桌面上拥有了强耦合以及不同的信任域。其结果是出现了新的漏洞类型，可以利用桌面作为公共接口。 </p>
<h6 id="信用传递的利用"><a href="#信用传递的利用" class="headerlink" title="信用传递的利用"></a>信用传递的利用</h6><p>一个很吸引人的Solaris安全问题显示了攻击者能够怎样在两个组件之间操纵它们的信任关系。一些版本的Solaris包括了使用root权限运行的RPC程序，<code>automonted</code>。这个程序允许root用户指定一个命令作为挂载操作的一部分运行，通常用于代表内核处理挂载和卸载。<code>automonted</code>程序不监听IP网络，只能通过三个受保护的环回传输访问，这意味着程序只接受来自root用户的命令，看起来还是很安全的。</p>
<p>另外一个程序，<code>rpc.stated</code>，在root权限下允许并且监听传输控制协议(  Transmission Control Protocol, TCP)和用户数据报协议（User Datagram Protocol， UDP）。它被用作网络文件系统(NFS)协议支持的一部分，它的目的是监视NFS服务再它们关停时发送通知。通常的，NFS锁定守护进程询问<code>rpc.stated</code>来监视服务器。然而，注册<code>rpc.stated</code>要求客服端告诉它要联系哪个主机，以及要在该主机上调用哪个RPC程序号。</p>
<p>因此攻击者就可以联系一台机器的<code>rpc.stated</code>然后注册<code>audomonted</code>程序以接收崩溃通知。然后攻击者告诉<code>rpc.stated</code>被监视的NFS服务器崩溃了。于是<code>roc.stated</code>在本地机器上联系<code>automonted</code>守护进程（通过一些特殊的回送接口（look back interface））然后给它一个RPC消息。这个消息并不是<code>automonted</code>所期望的，但在一些修改之后，你就能对一个合法的<code>audomonted</code>请求进行解码。这个请求通过回送接口发自root，于是<code>automonted</code>就认为这个请求来自于内核部分，而结果是它执行了攻击者选择的命令。</p>
<p>在这个例子中，攻击<code>rpc.stated</code>的公共接口只在与<code>automonted</code>建立信任通信时有用。这个情况会发现因为所有在相同账户下运行的进程都是相互信任的，利用这种信任可以让远程攻击者向<code>automonted</code>进程发送命令。最终关于通信源的假设导致开发人员对<code>automonted</code>所接受的格式比较宽容。这个问题与模块之间的相互信任结合导致了远程root级别的漏洞。</p>
<h6 id="故障处理"><a href="#故障处理" class="headerlink" title="故障处理"></a>故障处理</h6><p>在软件设计中，正确的故障处理是清晰准确的可用性的重要组成部分。你当然只是希望应用程序能够正确地处理不正常的情况，并为用户提供解决问题的帮助。但是，故障条件可能会导致可用性和安全性出现冲突。有时，必须对应用程序的功能进行妥协，以实现安全性。 </p>
<p>考虑一个网络程序，它检测客户端系统收到的数据中的故障或者故障条件。准确而清晰的可用性要求应用程序尝试恢复并继续运行。当无法恢复时，应用程序应该通过提供有关错误的详细信息来帮助用户诊断问题。</p>
<p>然而，面向安全的程序通常采用完全不同的方法，这可能涉及终止客户端会话和提供最低限度的必要反馈。之所以采用这种方法，是因为围绕安全理想而设计的程序假定故障条件是攻击者操纵程序输入或环境的结果。从这个角度来看，绕过问题并继续处理的尝试通常会正中攻击者的下怀。务实的防御反应是放弃正在发生的事情，在日志中发出血腥的尖叫，并终止处理。尽管这种反应似乎违反了一些设计原则，但这只是安全性需求的准确性取代了可用性需求的准确性和明确性的一种情况。 </p>
<h4 id="6-2-3-执行安全政策"><a href="#6-2-3-执行安全政策" class="headerlink" title="6.2.3 执行安全政策"></a>6.2.3 执行安全政策</h4><p>第一章讨论了安全期望以及它时怎样影响一个系统的。现在你可以用这些概念来理解安全期望是怎样来执行安全政策的。 开发人员主要通过识别和加强信任边界来实现安全政策。作为一名审计人员，你需要分析这些边界的设计以及实现它们的实施的代码。为了更容易地处理安全策略的元素，执行被分成六个主要类型，在下面的部分中讨论。 </p>
<h5 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h5><p>身份验证（authentication） 是程序确定用户声明的身份，然后检查该声明的有效性的过程。软件组件在发起通信时使用身份验证来建立对等方(客户端或服务器)的标识。一个典型的例子是要求网站的用户输入用户名和密码。正如你在前面关于SSL证书的讨论中所看到的，身份验证也不仅适用于人类。在此示例中，系统彼此进行身份验证，以在不可靠的接口上安全地运行。 </p>
<h6 id="常见的身份验证漏洞"><a href="#常见的身份验证漏洞" class="headerlink" title="常见的身份验证漏洞"></a>常见的身份验证漏洞</h6><p>一个值得注意的设计疏忽是在需要身份验证的情况下不进行身份验证。例如，一个Web应用程序提供了一个可能对内幕交易有用的敏感公司会计信息的摘要。将这些信息暴露给任意的互联网用户，而不要求进行某种身份验证，这将是一个设计缺陷。请注意，“缺乏身份验证”问题并不总是很明显，尤其是在大型应用程序中处理对等模块时。通常很难确定攻击者是否可以访问两个组件之间的内部接口。 </p>
<p>通常，最佳实践是在设计中集中身份验证，特别是在Web应用程序中。有些Web应用程序要求通过主页访问的用户进行身份验证，但在后续页面中不强制进行身份验证。这种身份验证的缺乏意味着你不需要输入用户名或密码就可以与应用程序进行交互。相反，集中式身份验证通过验证受保护域中的每个Web请求来缓解这个问题 </p>
<h6 id="不可信的凭证"><a href="#不可信的凭证" class="headerlink" title="不可信的凭证"></a>不可信的凭证</h6><p>另一个常见的错误发生在向软件提供一些身份验证信息，但这些信息不值得信任。当在客户端执行身份验证时，这个问题经常发生，攻击者通过它可以完全控制连接的客户端。例如，SunRPC框架包括了<code>AUTH_UNIX</code>身份验证方案，这个方案是给予完全信任客户端系统的。客户端只是传递一条记录，该记录高屋服务器用户以及组的id是什么，而服务器只将他们作为事实接受。</p>
<p>UNIX系统以前包括一个RPC保护进程叫<code>rexed</code>（远程执行守护进程，  remote execute daemon ）。这个程序的目的是让远程用户像本地用户一样运行程序。如果你连接上了一个<code>rexed</code>系统然后告诉<code>rexed</code>程序运行<code>/bin/sh</code>命令，程序就会将shell像bin一样运行然后让你和它进行交互。这就是它的全部功能，除了不能作为root用户运行程序之外。特别地，在将shell作为bin运行之后，只需要几分钟就可以绕过这个限制。最近，一个远程root缺陷，在Solaris上默认安装的<code>sadmind</code>暴露了， 它将<code>AUTH_UNIX</code>身份验证作为代表客户机运行命令的充分验证。 </p>
<h5 id="注"><a href="#注" class="headerlink" title="注"></a>注</h5><p>关于<code>sadmind</code>的bug文档见  <a href="http://www.securityfocus.com/bid/2354/info" target="_blank" rel="noopener">www.securityfocus.com/bid/2354/info</a>  </p>
<p>许多网络守护进程使用网络连接或包的源IP地址来建立对等点的身份确认。对于它自己来说，这个信息不足够可信并且容易收到篡改。UDP可以被很简单的方法欺骗，TCP连接也可以在很多情况下被欺骗或者拦截。UNIX提供了多个守护进程，它们遵循基于源地址的可信主机的概念。这些守护进程是<code>rshd</code>和<code>rlogind</code>，甚至<code>sshd</code>也可以通过配置来遵守这些信任关系。攻击者可以利用两个机器的信任关系，从这些受信任的机器中的高权限的端口通过初始化，欺骗攻击或者劫持一个TCP连接。</p>
<p>你可能在两个系统的程序化的身份认证中看到这种设计缺陷。如果程序使用这种身份认证机制，例如证书，设计层面的问题就会出现。首先，很多分布式的客户端/服务器应用只从一个方面认证身份：只通过客户端或者只通过服务器。攻击者经常可以利用这种身份验证的结构伪装成未经身份验证的用户，并对系统进行微妙的攻击。</p>
<p>使用加密方法自制的身份验证也是你可能常会遇到的问题。从一个概念性的角度来看，验证自己的身份看起来很简单。(<em>此处省略一段难翻译的废话 –by译者</em>)。但是，在从头创建身份验证协议时，有很大的错误空间。Thomas Lopatic在Firewall-1和FWN/1协议中发现了一个有趣的漏洞。每个对等点发送一个随机数R1和该随机数的哈希值以及共享密钥，Hash(R1+K).接收端库查看发送的随机数，计算哈希值，并将其与传输的值进行比较。问题是，你可以简单地将R1和Hash(R1+K)的值在服务器中重现，因为它们时使用相同的共享对称密钥生成的。</p>
<h5 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h5><p>授权是一个决定系统中的用户拥有什么样的权限在信任域中去做一些特定事务的过程。它作为<strong>权限控制</strong>(access control)策略的一部分与身份验证是一致的：身份验证告诉了这个用户是谁，授权决定了这个验证过的身份拥有做什么的权限。 有许多访问控制系统的正式设计，包括自由访问控制、强制访问控制和基于角色的访问控制。 此外，有几种技术可用于将访问控制集中到各种框架、操作系统和库中。由于不同访问控制方案的复杂性，最好从一般的角度来看待授权。 </p>
<h6 id="一般的授权漏洞"><a href="#一般的授权漏洞" class="headerlink" title="一般的授权漏洞"></a>一般的授权漏洞</h6><p>Web应用经常没有或者缺少足够的授权。你经常能发现只有一小部分网站做到了授权的检查。带有授权逻辑的页面通常是主菜单页面和主要子页面，但是实际的处理程序页面省略了授权检查。通常情况下，找到一种方法以相对低权限的用户登陆，然后能执行一些访问不属于你的账户信息以及做一些不属于你账户的行为这些为高权限用户所准备的操作。</p>
<h6 id="不安全的授权"><a href="#不安全的授权" class="headerlink" title="不安全的授权"></a>不安全的授权</h6><p>缺少授权显然是一个问题。你还可能遇到授权检查的逻辑不一致或者留下滥用空间的情况。例如，假如你有一个简单的消费跟踪系统，每个在公司的用户都有自己的账号。这个系统使用了公司的等级架构进行编写，所以它直到哪些员工是管理者，哪些是被管理者。它的主逻辑是像下面这样的数据驱动：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Enter New Expense</span><br><span class="line">for each employee you manage</span><br><span class="line">	View&#x2F;Approve expenses</span><br></pre></td></tr></table></figure>

<p>这个系统非常简单。假设初始化的公司员工等级架构是正确的，管理者可以审查与批准他们下属的费用。一般员工只能见到<code>Enter New Expense</code>的界面因为他们并不是管理者。</p>
<p>现在假设你在这样一种情况下运行这个程序，即一些员工都被一个人管理，但实际上他们要向另一个管理者报告日常事务。为了解决这个问题，你对这个程序做了这样的更改，即允许每个用户去选择其他用户作为自己的“虚拟的”管理员。一个用户的虚拟管理员(virtual manager)拥有查看与批准这个用户费用的权力，就像这个用户真正的管理员一样。这个解决方案第一眼看起来似乎还行，但它是有缺陷的。它可以允许用户将自己亲密的同事设置为虚拟管理员，包括他自己，这将导致费用的批准不受到任何限制。</p>
<p>这个简单的系统有一个明显的问题，可能看起来是人为设计的，但它是从实际应用中遇到的问题派生出来的。随着应用程序中的用户和组数量的增加以及系统复杂性的增加，设计人员很容易忽略授权逻辑中潜在的滥用可能性。 </p>
<h5 id="可追责性"><a href="#可追责性" class="headerlink" title="可追责性"></a>可追责性</h5><p>可追责性(Accountability) 就是一个系统能够确认以及记录用户在系统中的所作所为。不可抵赖性是一个相关术语，实际上是可追责性的一个子集。 它指的是系统对某些用户操作进行日志记录的保证，这样用户就不能否认曾经执行过这些操作。 可追责性，身份验证和授权共同建立了完整的权限控制策略。不像身份验证和授权，可追责性并不形成一个信任边界或者防止漏洞的发生。但是，可追责性提供的数据对于减轻成功的入侵和进行法医式的分析(forensic analysis)是必不可少的。不幸的是，可追责行是应用程序设计安全中最容易忽视的部分之一。</p>
<h6 id="常见的可追责性漏洞"><a href="#常见的可追责性漏洞" class="headerlink" title="常见的可追责性漏洞"></a>常见的可追责性漏洞</h6><p>最常见的可追责性漏洞就是一个系统对于登陆操作与敏感数据记录的失效。事实上，很多应用并不提供日志功能。当然，许多应用也不提供处理敏感数据时的日志记录。然而，管理者或者最终用户开发者需要决定什么样的日志记录是需要的。</p>
<p>另外一个主要的可追责性漏洞就是系统并没有正确地保护它的日志数据。当然，这个问题也可以划分为授权，保密性或者完整性漏洞。不管如何，任何系统在维护日志时需要保证它的安全。例如，下面展示了一个简单的文本日志，每行记录了时间戳以及登陆日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">20051018133106 Logon Failure: Bob</span><br><span class="line">20051018133720 Logon Success: Jim</span><br><span class="line">20051018135041 Logout: Jim</span><br></pre></td></tr></table></figure>

<p>如果我在用户名上做手脚又会发生什么呢？比如说，一个叫<code>&quot;Bob\n20051018133106 Logon Success: Greg&quot;</code>的用户名看起来人畜无害，但是它确实可以用来做坏事。攻击者可以使用假的登录信息去掩盖有害的登陆，或者破坏日志使其变得不可读或者不可写。 这种破坏可能会造成拒绝服务的情况，或者打开通向其他漏洞的通道。它甚至可以在日志系统本身中提供可利用的路径。 </p>
<p>除了这种日志的维护以外还有其他问题。如果攻击者能够读取日志呢？至少他们能够直到什么时候哪个用户会登入或者登出。从这个数据中，他们可能推断出一些登陆规律或者监视哪些用户会有忘记密码的习惯。这种信息看起来人畜无害，但它能为更大的攻击埋下伏笔。因此，未经授权的用户不能够向系统日志读取内容进行或者写入操作。</p>
<h5 id="保密性"><a href="#保密性" class="headerlink" title="保密性"></a>保密性</h5><p>第一章给出了保密性的定义，即只有经过授权的一方才能够查看数据。这要求通过权限控制机制来实现，这种机制囊括了身份验证和授权。然而当通信在不安全的地段发生时，我们必须对安全引入新的考量(additional measure)。在这种情况下，加密技术通常用来满足保密性的需求。</p>
<p><strong>加密</strong>(eccryption) 就是一个对信息编码的过程，如果第三方没有相关的知识（即解码方法 –by译者），那他就无法获得信息的确切内容。加密过程通常对一些数据有核心意义。核心数据只有通过授权之后才能访问其信息。</p>
<p>关于加密算法以及过程的主体并没有包含在在本书中，因为这其中的数学非常复杂，包含了一整个研究领域，要对它们有更深的了解，参考这本书：实用密码学 by   Bruce Schneier and Niels Ferguson .（<em>此处省略一些废话 –by译者</em>）</p>
<h6 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h6><p>加密方法有很悠久的历史。然而我们关心的是可以用来有效保护交流数据的现代加密协议，本章我们关注两种加密的类别：对称型和反对称型。</p>
<p>对称加密(symmetric encryption) 或者共享密钥加密是一类所有授权方共享一份相同密钥的加密算法。 对称算法通常是最简单和最有效的加密算法。它们的主要缺点是，它们要求多方能够访问相同的共享机密。另一种方法是为每个通信关系生成和交换一个惟一的密钥，但是这种解决方案很快会导致无法维持的密钥管理情况。此外，非对称加密无法在任何共享密钥用户组中验证消息的发送方。 </p>
<p>非对称加密(asymmetric encryption)(或公钥加密)是指每一方都有一组不同的密钥来访问相同加密数据的算法。这是通过为每一方使用一个公钥和私钥对来完成的。任何希望通信的各方都必须提前交换它们的公钥。然后，通过组合接收方的公钥和发送方的私钥对消息进行加密。生成的加密消息只能通过使用接收方的私钥解密。此外，非对称加密无法在任何共享密钥用户组中验证消息的发送方。 </p>
<p>也就是说，非对称加密简化了密钥管理，并不要求暴露私有密钥，并且隐式地验证发送者的信息。然而， 非对称算法通常用于交换对称密钥，然后在通信会话期间使用该密钥。 </p>
<h6 id="分组密码"><a href="#分组密码" class="headerlink" title="分组密码"></a>分组密码</h6><p>分组密码(block cipher)是一种对称加密算法， 它在固定大小的数据块上工作，并以多种模式运行。但是，在使用它们时，你应该知道一些注意事项。一个需要考虑的问题是，分组密码是独立加密每个组，还是使用前一个组的输出加密当前组。独立加密组的密码更容易受到密码分析攻击（cryptanalytic attacks ），应该尽可能避免。因此，分组密码链(cipher block chaining， CBC)模式密码是常规使用的唯一合适的固定组密码。它使用前面的数据组执行XOR操作，导致的性能开销可以忽略不计，并且比独立处理组的模式具有更高的安全性。 </p>
<h6 id="流密码"><a href="#流密码" class="headerlink" title="流密码"></a>流密码</h6><p>分组密码的最不便之处就在于它必须处理固定大小的数据组。任何一组数据如果比size大都必须分段，小于size的组必须进行填充。这个要求会在处理一些数据比如标准的TCP套接字(TCP socket)时为代码添加复杂度和难度。</p>
<p>幸运的是，分组密码可以允许在数据块大小任意时运行。在这种情况下，分组密码作为流密码（stream cipher）运行。 <strong>计数器</strong>(counter， CTR)模式密码是流密码的最佳选择。它的性能特征与CBC模式相当，但不需要填充或分段。 </p>
<h6 id="初始化向量"><a href="#初始化向量" class="headerlink" title="初始化向量"></a>初始化向量</h6><p>初始化向量（initialization vector）时用来启动分组密码的初始段。一个初始化向量需要进行加密时给出唯一的输出流，不管输入是否相同。初始化向量不需要保证私有（keep private），尽管它对于相同的密钥在每次新的加密过程中都必须不同。在有限的情况下，重复使用用初始化向量会导致使用CBC密码的信息泄漏;然而，它严重降低了其他块密码的安全性。一般来说，初始化向量的重复使用应该被认为是一个安全漏洞。 </p>
<h6 id="密钥交换算法"><a href="#密钥交换算法" class="headerlink" title="密钥交换算法"></a>密钥交换算法</h6><p>密钥交换协议的形式可以非常复杂，所以这一小节仅仅提供一些简单的知识点。首先，它的实现上应该使用标准密钥，比如RSA，  Diffie-Hellman, o 或者El Gamal.  这些算法都已经被广泛验证，并且提供了最高等级的保障。</p>
<p>下一个问题是密钥交换是以一种安全的方式执行的，这意味着通信双方必须提供一些识别方法来防止中间人攻击。前面提到的所有密钥交换算法都提供了相关的签名算法，可用于验证连接的两端。这些算法要求双方已经交换了公钥，或者可以通过可信的源(如公钥基础设施(  Public Key Infrastructure ,PKI)服务器)获得公钥。 </p>
<h6 id="加密过程的常见漏洞"><a href="#加密过程的常见漏洞" class="headerlink" title="加密过程的常见漏洞"></a>加密过程的常见漏洞</h6><p>现在你已经有了一些关于正确使用加密的背景知识，了解什么地方可能出错是很重要的。自定义加密是与机密性相关的漏洞的主要原因之一。加密是非常复杂的，需要广泛的知识和测试来正确设计和实现。因此，大多数开发人员应该将自己限制在已知的算法、协议和实现上，这些算法、协议和实现都经过了广泛的审查和测试。</p>
<h6 id="不必要地存储敏感数据"><a href="#不必要地存储敏感数据" class="headerlink" title="不必要地存储敏感数据"></a>不必要地存储敏感数据</h6><p>通常情况下，没有任何实际原因就去设计维护敏感据，通常是因为对系统需求的误解。例如，验证密码不需要将密码存储在可检索的表单中。你可以安全地存储密码的哈希值并使用它进行比较。如果操作正确，此方法可以防止真正的密码被公开。(如果你不熟悉哈希值，请不要担心;它们将在本章后面的“哈希函数”中介绍。) </p>
<p>明文密码是不必要地存储数据的最典型的情况之一，但它远不是这个问题的唯一例子。有些应用程序设计不能正确地对敏感信息进行分类，或者只是莫名其妙地将其存储起来。真正的问题是，任何设计都需要正确地对其数据的敏感性进行分类，并且只在绝对需要时才存储敏感数据。 </p>
<h6 id="缺少必要的加密"><a href="#缺少必要的加密" class="headerlink" title="缺少必要的加密"></a>缺少必要的加密</h6><p>通常，如果系统的设计目的是在可公开访问的存储、网络或不受保护的共享内存段之间传输明文信息，那么它就不能提供足够的保密性。例如，使用TELNET交换敏感信息几乎肯定是与机密性相关的设计漏洞，因为TELNET不加密其通信通道。</p>
<p>一般来说，任何有可能包含敏感信息的通信，在经过可能受到危害的公共网络时，都应该进行加密。在适当的情况下，应该在敏感信息存储在数据库或磁盘时对其进行加密。加密需要某种密钥管理解决方案，它通常可以绑定到用户提供的秘密，例如密码。在某些情况下，特别是在存储密码时，可以将敏感数据的散列值存储在实际敏感数据的位置。 </p>
<h6 id="不足的或者过时的加密"><a href="#不足的或者过时的加密" class="headerlink" title="不足的或者过时的加密"></a>不足的或者过时的加密</h6><p>当然，使用设计不够强大的加密技术来提供所需的数据安全性也是有可能的。例如，56位的单一数字加密标准( Digital Encryption Standard，DES)加密可能是当前廉价的千兆赫计算机时代的一个糟糕的选择。请记住，攻击者可以记录加密的数据，如果这些数据足够有价值，他们可以在计算能力提高的后再等待解密成果。最终，他们将能够在Radio Shack公司获得一台128 q位的量子计算机，你的数据将属于他们(假设科学家在2030年前解决了老龄化问题，每个人都能长生不死)。 </p>
<p>撇开玩笑不谈，重要的是要记住加密实现是会随着时间而变老的。计算机变得更快了，数学家发现算法中出现了新的漏洞，就像代码审核员在软件中发现的漏洞一样。一定要注意算法和密钥大小，它们不适合所保护的数据。当然，这是一个不断变化的目标，所以你所能做的最好的事情就是了解当前推荐的标准。国家标准和技术研究所(NIST;(<a href="http://www.nist.gov)在发布算法和密钥大小的普遍接受标准方面做得很好。" target="_blank" rel="noopener">www.nist.gov)在发布算法和密钥大小的普遍接受标准方面做得很好。</a> </p>
<h6 id="数据混淆与数据加密"><a href="#数据混淆与数据加密" class="headerlink" title="数据混淆与数据加密"></a>数据混淆与数据加密</h6><p> 一些应用程序甚至整个行业的安全标准似乎无法区分数据混淆（Obfuscation）和数据加密。简单地说，当攻击者能够访问恢复编码的敏感数据所需的所有信息时，数据就会变得混淆。这种情况通常发生在编码数据的方法没有包含唯一密钥，或者密钥与数据存储在同一个信任域中的情况下。不包含唯一密钥的编码方法的两个常见示例是ROT13文本编码和简单的XOR机制。 </p>
<p>将密钥存储在与数据相同的上下文中的问题更令人困惑，但并不一定就不那么常见。例如，许多支付处理应用程序在其数据库中存储加密的敏感帐户持有人信息，但所有处理应用程序都需要密钥。这一要求意味着，窃取备份媒介可能不会向攻击者提供帐户数据，但破坏任何支付服务器都可以让他们获得密钥和加密的数据。当然，你可以添加另一个密钥来保护第一个密钥，但是所有处理应用程序仍然需要访问。你可以按自己的意愿分层存储任意多的密钥，但最终，这只是一种混淆技术，因为每个处理应用程序都需要解密敏感数据。 </p>
<h5 id="注-1"><a href="#注-1" class="headerlink" title="注"></a>注</h5><p>支付卡行业( Payment Card Industry， PCI)1.0数据安全要求是整个行业标准的一部分，以帮助确保安全处理支付卡数据和交易。这些需求是业界的一个前瞻性举措，其中许多与最佳安全实践保持一致。然而，该标准包含的要求恰恰产生了本章所述的机密性问题。特别是，要求允许将加密的数据和密钥存储在相同的上下文中，只要密钥是由驻留在相同上下文中的另一个密钥加密的。 </p>
<p>最后一点是，在过去的几年中，通过模糊(或混淆)实现的安全性已经赢得了不好的名声。就其本身而言，它还不足以保护数据不受攻击者的攻击;它只是没有提供足够强的保密性。然而，在实践中，混淆可能是任何安全策略的一个有价值的组成部分，因为它可以阻止偶然的窥探者，并且通常可以放缓专业的攻击者的脚步。 </p>
<h5 id="完整性"><a href="#完整性" class="headerlink" title="完整性"></a>完整性</h5><p>第一章将完整系定义为只有经过授权的用户能够修改数据的期望。这个需求像保密性一样也是通过权限管理机制来实现的。 但是，当通过不安全的通道进行通信时，必须采取其他措施。在这些情况下，将使用下面讨论的某些加密方法来确保数据完整性。 </p>
<h6 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h6><p>加密数据的完整性时通过各种方法来实现的，尽管哈希函数是大多数方法的基础。哈希函数,或者消息摘要函数( message digest function）接受可变长度的输入并生成固定大小的输出。哈希函数的有效性主要通过三个要求来衡量。首先它必须是不可逆的，也就是知道输出，不能确定输入。这个要求称为无预映像（no pre-image）要求。第二个要求是函数没有预映像，也就是给定输入和输出，不能生成具有相同输出的输入。最后也是最严格的，哈希函数必须相对无中途，也就是不可以由不同的输入生成相同的输出。</p>
<p>哈希函数提供了大多数编程完整性保护的基础。它们可用于将任意一组数据与惟一的、固定大小的值相关联。这种关联可以用来避免保留敏感数据，并大大减少验证数据所需的存储空间。哈希函数最简单的形式是循环冗余校验(cyclic redundancy check，CRC)例程。它们速度快、效率高，并提供了一定程度的保护，防止无意的数据修改。然而，CRC函数对有意修改无效，这使得它们不能用于安全目的。一些常用的CRC函数包括CRC-16、CRC-32和Adler-32。 </p>
<p>CRC函数的下一步是加密哈希函数。它们的计算量要大得多，但它们对有意和无意的修改提供了高度的保护。常用的哈希函数包括SHA-1、SHA-256和MD5。(有关MD5的问题将在本章后面的“诱饵-开关攻击”中详细讨论。) </p>
<h6 id="盐值"><a href="#盐值" class="headerlink" title="盐值"></a>盐值</h6><p>盐值(salt values)(<em>这个真不知道怎么翻译，那就借用大逼乎的盐值吧 –by 译者</em>)和初始化向量几乎非常相近。’salt‘表示信息中加入了一些随机数以至于两条信息不会生成相同的哈希值。相比于初始化向量，盐值<em>必须不能</em>从信息之间复制。除了哈希值之外，还必须存储一个盐值一遍能够正确地重构柴窑以进行比较。 然而和初始化向量不同的是， 盐值在大多数情况下应该得到保护。 </p>
<p>盐值最常用来防止基于预计算的对消息摘要的攻击。大多数密码存储方法都用一个固定的哈希值来防止这个问题。再预计算攻击中，攻击者构建一个包含所有可能摘要值得字典，以便能够确定原始数据值。这种方法只适用于输入值很小的范围，比如密码，然而它在这种范围内可以非常有效。</p>
<p>考虑一个应用于任意密码的32位随机值。盐值将密码预计算字典的大小增加了40亿倍(232)。由此产生的预计算字典对于密码的一小部分来说可能太大了。由Philippe Oechslin开发的Rainbow表是一个真实的例子，它说明了缺少盐值会使密码哈希容易受到预计算攻击。Rainbow表可用于在几秒钟内破解大多数密码哈希，但这种技术只有在散列不包含盐值的情况下才有效。你可以在Project RainbowCrack网站上找到更多关于彩虹表的信息:<a href="http://www.antsight.com/zsl/rainbowcrack/。" target="_blank" rel="noopener">http://www.antsight.com/zsl/rainbowcrack/。</a> </p>
<h6 id="发起者验证"><a href="#发起者验证" class="headerlink" title="发起者验证"></a>发起者验证</h6><p>哈希函数提供了验证消息内容的方法，但是它们不能验证消息源。验证消息的来源需要在哈希操作中加入某种形式的私钥;这种类型的函数称为基于哈希的消息验证码( hash-based message authentication code HMAC)函数。消息验证码是一个函数，返回从密钥和可变长度消息计算得到的固定长度值。 </p>
<p>基于哈希的消息验证码是一种使用共享秘密验证消息内容和发送方的相对快速的方法。不幸的是，基于哈希的消息验证码与任何共享密钥系统都有相同的弱点:攻击者可以通过仅泄漏一方的密钥来模拟对话中的任何一方。 </p>
<h6 id="加密签名"><a href="#加密签名" class="headerlink" title="加密签名"></a>加密签名</h6><p>加密签名（Cryptographic Signatures）是一种将消息摘要与特定公钥相关联的方法，它使用发送方的公钥和私钥对消息摘要进行加密。 任何收接收者可以使用发送者的公钥对消息摘要进行解码然后讲结果值与计算后得到的消息摘要做比较。这种比较为消息来源者必须对密钥具有访问权提供了保证。</p>
<h6 id="完整性的常见漏洞"><a href="#完整性的常见漏洞" class="headerlink" title="完整性的常见漏洞"></a>完整性的常见漏洞</h6><p>完整性漏洞和保密性漏洞很相似，大多数完整性漏洞事实上可以通过对保密性的严格要求来预防。接下来几小节讨论在一些特定的情况下与完整性有关的设计漏洞。</p>
<h6 id="诱骗攻击（Bait-and-Switch-Attacks）"><a href="#诱骗攻击（Bait-and-Switch-Attacks）" class="headerlink" title="诱骗攻击（Bait-and-Switch Attacks）"></a>诱骗攻击（Bait-and-Switch Attacks）</h6><p>（<em>注：Bait-and-Switch为美国俚语，bait即引诱别人的鱼饵鱼饵，switch即在别人上套之前用别的东西替代，这里翻译为诱骗 –By译者</em>）</p>
<p>常用的哈希函数必须接受大量的公共审查。然而，随着时间的推移，出现的弱点往往可以被攻击者利用。<strong>诱骗攻击</strong>就是对几种首先被发现的老以前哈希函数的弱点之一实行打击的。这种攻击利用了哈希函数在一些特定范围的输入中倾向于产生冲突的弱点。攻击者可以利用这种弱点用两个不同的输入产生相同的值。</p>
<p>例如，假设你有一个处理钱款转账请求的银行应用程序。这个程序收取请求，如果请求是合法的，那么就进行转账步骤。如果哈希函数是有缺陷的，攻击者就可以生成两笔拥有相同信息摘要的转账。然后攻击者可以用最低余额开设帐户，并获得较小的转账批准。然后，他们会向下一个系统提交更大的请求，并在其他人知道之前结清账户。 </p>
<p>诱骗攻击最近是一个流行的主题因为SHA-1和 MD5已经开始被发现出了一些弱点。MD5的冲突漏洞最早在1996年就被发现，但直到2004年四个人（<em>名字不翻译了 –by译者</em>）发表了一篇成功导致MD5冲突漏洞算法的文章。2005年三月，三个研究者又紧随其后， 他们成功地生成了一对具有不同公钥的X.509证书，这是SSL中使用的证书格式。  最近，Vlastimil Klima在2006年3月发布了一种算法，能够在极短的时间内找到MD5碰撞。 </p>
<p> SHA算法家族也受到密切关注。若干对SHA-0的潜在攻击已经确定了;但在SHA-0很快就被SHA-1所取代，并且没有出现任何明显的漏洞。SHA-0攻击研究为识别SHA-1算法的漏洞提供了基础，尽管在撰写本文时，还没有任何一方成功地生成SHA-1冲突。然而，这些问题已经导致了几个主要的标准机构(如美国)开始逐步淘汰SHA-1，支持SHA-256(也称为SHA-2)。 </p>
<p>当然，寻找随机冲突比寻找可以实施诱骗攻击的碰撞要困难得多。然而，就其本质而言，选择加密算法时应考虑到其安全性将远远超出适用系统的生命周期。这种观点解释了近年来哈希算法的转变，哈希算法之前被认为是相对安全的。这种变化的影响甚至可以在密码哈希应用程序中看到，这些应用程序不直接受到基于冲突的攻击，但也被升级为更强大的哈希函数。 </p>
<h5 id="实用性"><a href="#实用性" class="headerlink" title="实用性"></a>实用性</h5><p>第1章实用性定义为在需要时使用资源的能力。这种实用性预期通常与可靠性有关，而与安全性无关。但是，在许多情况下，系统的可用性应该被视为安全需求。 </p>
<h6 id="常见的实用性漏洞"><a href="#常见的实用性漏洞" class="headerlink" title="常见的实用性漏洞"></a>常见的实用性漏洞</h6><p>与实用性设计失败相关的一般漏洞只有一种类型——拒绝服务(denial-of-service， DoS)漏洞。当攻击者可以通过执行一些未预期的操作使系统不可用时，就会出现DoS漏洞。 </p>
<p>DoS攻击的影响很大程度上取决于它发生的环境。一个关键的系统可能包含对持续实用性的期望，而进程中断往往是不可接受的业务风险。核心业务系统(如集中式身份验证系统或旗舰网站)通常都是这种情况。在这两种情况下，成功的DoS攻击可能直接导致收入的重大损失，因为企业在没有系统的情况下无法正常运作。实用性的缺乏还会带来安全风险，因为停机会迫使以不太安全的方式处理需求。例如，考虑一个销售点(point-of-sale，PoS)系统，该系统通过一个中央调节服务器处理所有信用卡交易。当调节服务器不可用时，PoS系统必须在本地暂时存储所有事务，并在稍后的时间执行它们。攻击者在PoS系统和协调服务器之间诱导DoS的原因可能有很多。DoS条件可能允许攻击者用偷来的或无效的信用卡购物，也可能在不太安全的PoS系统上暴露持卡人信息。 </p>
<h4 id="6-2-4-威胁建模"><a href="#6-2-4-威胁建模" class="headerlink" title="6.2.4 威胁建模"></a>6.2.4 威胁建模</h4><p>现在，你应该对设计如何影响软件系统的安全性有了很好的了解了。系统定义了向用户提供的功能，但受安全策略和信任模型的约束。下一步是将你的注意力转移到开发一个将这些知识应用到您要审查的应用程序的过程上。理想情况下，你需要能够识别系统设计中的缺陷，并根据最安全关键的模块对实现审查进行优先级排序。幸运的是，一种称为<strong>威胁建模</strong>（threat modeling）的形式化方法正是为此目的而存在的。 </p>
<p>在这一节，你将会使用具体有5个步骤阶段的威胁建模方式：</p>
<ul>
<li>信息收集</li>
<li>应用架构建模</li>
<li>威胁识别</li>
<li>对寻找的结果进行文档记录</li>
<li>确定实施审查的优先次序</li>
</ul>
<p>此过程是在开发的设计(或重构)阶段最有效的应用，并在稍后的开发阶段进行修改时更新。但是，它可以在SDLC的稍后阶段完全集成。它还可以在开发后应用，以评估应用程序的潜在风险。你选择的阶段取决于自己的需求，但是请记住，设计审查只是完整应用程序评审的一个组成部分。因此，请确保考虑到执行最终系统的实现和操作审查的需求。 </p>
<p>这种威胁建模方法有助于建立一个框架，将你已经学过的许多概念联系起来。这个过程也可以作为本书其余部分中应用许多概念的路线图。但是，你应该学会调整，根据需要更改这些技术，以适应不同的情况。请记住，过程和方法可以成为好的仆人，但不是好的主人。 </p>
<h5 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h5><p>威胁建模的第一步就是集中应用程序中的所有信息。在这个阶段你应该不要把太多精力花在只和安全相关的信息因为在这个阶段你还不知道什么信息是和安全相关的。相反，你应该为最终的实现阶段审查提供为了理解整个程序尽可能多的信息。下面是在完成这个步骤后你需要确定的信息：</p>
<ul>
<li>资产。资产包括了在这个系统中所有对于攻击者有价值的东西。它们可能是在应用中包含的数据或者附加的数据库，例如包含用户账号和尼玛的数据表。资产也可以认定为应用程序的某些部分，例如在目标系统中运行任意代码的能力。</li>
<li>进入点。进入点包括任何攻击者可以连接上系统的路径。它们包括主动暴露的结构，比如监听接口，远程过程调录（Remote Procedure Call ，RPC）终点，上传的文件或者任何客户端发起的活动。</li>
<li>外部信任等级。外部新人等级也就是一个外部实体所拥有的权限，就像在本章前面“信任关系”所讨论的那样。一个复杂的系统可能会对不同的外部实体有好几个外部信任等级，但一个简单的应用程序应该只会考虑局部和远程访问权限的问题。</li>
<li>主要的组件。主要的组件顶一个这个应用设计的结构。组件可以是在程序内部的，或者它们可以是外部的模块依赖。威胁建模过程包括了对这些组件进行分解然后确定只和安全相关部分的过程。</li>
<li>使用场景。使用场景涵盖了系统的所有潜在应用程序。它们包括了授权后的和未授权的使用场景。</li>
</ul>
<h6 id="开发者访谈"><a href="#开发者访谈" class="headerlink" title="开发者访谈"></a>开发者访谈</h6><p>在很多情况下，你可以节省很多时间，直接和开发人员交流。所以，如果你有机会接触到开发人员，一定要利用这种机会。当然，这个选项可能不可用。例如，独立的漏洞研究人员很少能够访问到应用程序的开发人员。 </p>
<p>当你接触系统开发人员时，您应该记住以下几点。首先，你可以批评他们投入了大量时间和精力的工作。要明确表示，你的目标是帮助提高应用程序的安全性，并避免在你的方法中出现任何主观判断或屈尊俯就的情况。在进行了适当的对话之后，你仍然需要验证针对应用程序实现获得的任何信息。毕竟，开发人员可能有自己的误解，这可能是导致某些漏洞的一个因素。 </p>
<h6 id="开发者文档"><a href="#开发者文档" class="headerlink" title="开发者文档"></a>开发者文档</h6><p>一个文档良好的应用程序可以使审查过程更快更彻底;然而，这种便利有一个主要问题。对于现有实现的任何设计文档，都应该始终保持谨慎。这种谨慎的原因通常不是欺骗或不称职的开发人员;只是在实现过程中发生了太多的变化，以至于结果无法完全符合规范。 </p>
<p>许多因素导致了规范和实现之间的不一致性。由于开发人员的更替和随着时间的推移而产生的轻微疏忽，非常大的应用程序常常会与它们的规范产生巨大的偏差。实现也可以不同，因为两个人很少对规范有完全相同的解释。底线是，你应该期望根据实际实现验证你从设计中确定的所有内容。 </p>
<p>请记住这一点，你仍然需要知道如何从你获得的文档中提取所有内容。一般来说，你希望得到你可以得到的任何东西，包括设计(图、协议规范、API文档等等)、部署(安装指南、发布说明、补充配置信息等等)和最终用户文档。在二进制(和一些源代码)评审中，你只能获得最终用户文档，但不要低估它的价值。此文档是“面向客户”的文献，因此它一般是相当准确的，并且可以提供以流程为中心的视图，从而使系统更易于理解。 </p>
<h6 id="标准文档"><a href="#标准文档" class="headerlink" title="标准文档"></a>标准文档</h6><p>了解这些协议和文件格式是如何构造的对于了解应用程序应该如何工作以及可能存在的缺陷是必要的。因此，获取由研究人员和作者创建的任何已发布的标准和相关文档是一个好主意。通常，与因特网相关的标准文档可以作为评论请求(Request for Comments . RFCs)(可在<a href="http://www.ietf.org/rfc/上获得)。相同标准的开源实现在澄清你在研究目标应用程序使用的技术时可能遇到的歧义方面特别有用。" target="_blank" rel="noopener">www.ietf.org/rfc/上获得)。相同标准的开源实现在澄清你在研究目标应用程序使用的技术时可能遇到的歧义方面特别有用。</a> </p>
<h6 id="源码概要分析"><a href="#源码概要分析" class="headerlink" title="源码概要分析"></a>源码概要分析</h6><p>当你试图收集关于应用程序的信息时，看看源代码的非常有用。在这个阶段，你不需要做得太深入，但是拥有源代码可以加快许多初始建模过程。源代码可用于初始验证文档，你可以从代码中的类和模块层次结构确定应用程序的一般结构。当源看起来不是分层布局的时候，你可以查看应用程序启动，以确定初始化时主要组件是如何区分的。你还可以通过浏览代码来识别入口点，以查找常见的函数和对象，如<code>listen()</code>或<code>ADODB</code>。 </p>
<h6 id="系统概要分析"><a href="#系统概要分析" class="headerlink" title="系统概要分析"></a>系统概要分析</h6><p>系统概要分析需要访问应用程序的功能，这使你有机会验证文档审查并识别文档遗漏的元素。从文档中严格执行的威胁模型需要跳过此步骤，并在实现检查期间完全验证模型。</p>
<p>你可以使用各种方法来分析应用程序。以下是一些常用的技巧:</p>
<ul>
<li>文件系统布局。查看程序的文件系统不觉然后记录任何重要信息。这些信息包括了确定权限结构，监听所有可运行模块，异界确定任何相关数据文件。</li>
<li>代码再利用。查看所有可能来自其它库或者包的应用程序组件，例如嵌入的Web服务器或者加密库。这些组件可能自己带有可以攻击的点，所以需要额外的审查。</li>
<li>输入和输出。列出所有模块函数的输入和输出。 仔细查看用于建立或管理外部连接或RPC接口的任何库 </li>
<li>沙盒测试。在沙盒中运行程序，然后识别它所触及的每个对象和它所执行的每个活动。使用探测器和应用程序代理来记录任何网络流量并隔离通信。在Windows环境，Filemon、Regmon、WinObj和来自(<a href="http://www.sysinternals.com)Process" target="_blank" rel="noopener">www.sysinternals.com)Process</a> Explorer中使用程序有助于这个步骤进行。 </li>
<li>扫描。 在任何监听端口、RPC接口或类似的外部接口上探测应用程序。尝试抓取横幅以验证正在使用的协议并确定任何身份验证需求。对于HTTP应用程序，尝试搜索链接并标识尽可能多的唯一入口点。 </li>
</ul>
<h5 id="应用程序架构建模"><a href="#应用程序架构建模" class="headerlink" title="应用程序架构建模"></a>应用程序架构建模</h5><p>了解了一些背景信息之后，你需要开始研究应用程序体系结构。这个阶段包括熟悉软件的结构，以及哪些组件会影响软件的整体安全性。这些步骤有助于确定设计关注点，并让你知道在实现审查期间应该将精力集中在哪里。你可以通过查看应用程序模型的现有文档并根据需要开发新模型来构建这些知识。在软件开发过程中，对软件的各个部分进行一定程度的建模;唯一的区别是这些模型是否被正式记录过。因此，你需要了解常用的建模类型以及如何开发自己的模型。 </p>
<h6 id="统一标记语言"><a href="#统一标记语言" class="headerlink" title="统一标记语言"></a>统一标记语言</h6><p>统一标记语言(Unified Markup Language, UML) 是由对象管理小组(OMG;(<a href="http://www.omg.org/uml/)来描述应用程序在相当高的层次上如何运行的许多不同方面。它包括描述信息流、组件之间的交互、应用程序可能处于的不同状态等的图表。在这个阶段中特别有趣的是类图、组件图和用例。下面的列表简要地描述了这些类型的图，以便你对它们试图表达的内容有一个大致的了解。如果你不熟悉UML，那么强烈建议你从关于这个主题的无数书籍中挑选一本。由于UML的复杂性，深入地解释它远远超出了本章的范围。" target="_blank" rel="noopener">www.omg.org/uml/)来描述应用程序在相当高的层次上如何运行的许多不同方面。它包括描述信息流、组件之间的交互、应用程序可能处于的不同状态等的图表。在这个阶段中特别有趣的是类图、组件图和用例。下面的列表简要地描述了这些类型的图，以便你对它们试图表达的内容有一个大致的了解。如果你不熟悉UML，那么强烈建议你从关于这个主题的无数书籍中挑选一本。由于UML的复杂性，深入地解释它远远超出了本章的范围。</a> </p>
<h5 id="注-2"><a href="#注-2" class="headerlink" title="注"></a>注</h5><p>UML已经经过了几个版本迭代，现在大家都用UML2.0.</p>
<ul>
<li><p>类图。类图是用于建模面向对象(OO)解决方案的UML图。每个对象类都由一个包含类中的方法和属性的矩形表示。然后，对象之间的关系由类之间的线表示。有箭头的线表示了继承关系，两端有数字没有箭头的线表示基数关系。</p>
<p>当你试图理解复杂模块中的关系时，类图会很有帮助。它们基本上阐明了应用程序如何建模以及类之间如何交互。然而，实际上，你不会经常遇到这些问题，除非您正在执行内部代码检查。通过分析OO解决方案，可以大致构造类图。尽管这样做似乎有点浪费时间，但是当你稍后需要回来审查相同的软件时，或者当你执行初始的高级审查，然后将各种代码审计任务交给团队的其他成员时，它们会很有用。 </p>
</li>
<li><p>组件图。组件图将解决方案划分为其组成的组件，连接符号用来它们之间的交互方式。组件被定义为一个不透明的子系统，它为解决方案提供一个独立的功能。组件的示例包括数据库、某种描述的解析器、排序系统等等。与类图相比，组件图提供的系统视图不太复杂，因为组件通常表示一个完整的自包含子系统，通常由许多类和模块实现。 </p>
<p>组件图公开接口用突出的圆圈表示，使用其他组件的接口用空半圆表示。组件通过这些接口公开或通过关联线的方式绑定在一起，这表明两个组件是内在相关的，不依赖于公开的接口。组件图还允许通过实现将两个组件连接在一起。实现仅仅意味着一个组件所需要的功能是另一个组件的接口所公开的功能的子集。实现用虚线表示。 </p>
<p>在审计过程中，组件图对于定义系统的高级视图及其组件间关系很有价值。当你试图开发威胁模型的初始上下文时，它尤其有用，因为它消除了系统的许多复杂性，并允许你关注全局。 </p>
</li>
<li><p>用例。用例可能是UML标准中最模糊的组件。对于用例应该是什么样子或者包括什么，没有严格的要求。它可以用文本或图形表示，开发人员可以选择自己喜欢的方式。从根本上说，用例旨在描述应用程序应该如何使用，因此一组好的用例可以派上用场。毕竟，当你知道应用程序应该做什么时，解决它不应该做什么就比较容易了。在评审用例时，要注意开发人员对系统行为的任何假设。 </p>
</li>
</ul>
<h6 id="数据流图"><a href="#数据流图" class="headerlink" title="数据流图"></a>数据流图</h6><p>许多绘图工具可以帮助理解系统，但是数据流图(data flow diagram, DFD)是最有效的安全工具之一。这些图用于映射数据如何在系统中移动，并标识任何受影响的元素。如果处理得当，DFD建模过程不仅要考虑直接向外部源公开的应用程序功能，还要考虑间接公开的功能。这个建模过程还考虑了系统设计中的缓和因素，例如加强信任边界的附加安全措施。图2-2显示了DFD的5个主要元素，总结如下: </p>
<p><img src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/the_art_of_security_assessment_translate/2-2.png" alt="2-2"></p>
<ul>
<li>流程。流程是不透明的逻辑组件，具有定义良好的输入和输出需求。它们用一个圆圈表示，相关的进程组用一个带有双边框的圆圈表示。可以在每个流程的附加dfd中进一步分解多个流程组。尽管流程不是典型的资产，但它们在某些上下文中可能是资产。 </li>
<li>数据存储。数据存储是系统使用的数据资源。例如文件和数据库。它们用由开放的矩形框表示。 通常任何在系统中的数据存储都属于资产。</li>
<li>外部实体。前面“信息收集”中描述的这些元素是“参与者”和远程系统，它们通过系统的入口点与系统通信。它们用封闭的矩形表示。识别外部实体可以帮助您快速隔离系统入口点，并确定哪些资产可以从外部访问。外部实体也可能表示需要保护的资产，例如远程服务器。 </li>
<li>数据流。数据流用箭头表示。它表示数据是从哪来到哪去。这些元素在发现哪些用户支撑的数据能够到达哪些特定组件很有帮助，因此这样你就可以在实现审查阶段对它们进行定位。</li>
<li>信任边界。信任边界就是在系统或者在两个系统之间的边界。它们用两个组件之间的虚线表示。</li>
</ul>
<p>图2-3演示了如何使用DFD元素建模系统。它表示基本Web应用程序的简化模型，允许用户登录并访问存储在数据库中的资源。当然，DFD在应用程序的不同级别上看起来是不同的。封装大型系统的简单、高级DFD称为上下文关系图。Web站点示例是一个上下文图，因为它表示封装了一个复杂系统的高级抽象。 </p>
<p><img src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/the_art_of_security_assessment_translate/2-3.png" alt="2-3"></p>
<p>然而，你的分析通常需要您进一步分解系统。每个连续的分解级别都用数字标记，从零开始。0级图标识了主要的应用程序子系统。这个Web应用程序中的主要子系统由用户的身份验证状态来区分。这种区别在图2-4的0级图中表示出来。 </p>
<p><img src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/the_art_of_security_assessment_translate/2-4.png" alt="2-4"></p>
<p>根据系统的复杂性，你可能需要继续分解。图2-5是Web应用程序登录过程的一级图。通常，在建模复杂的子系统时，你只用在0级图之上进行。然而，这个1级图也为使用dfd隔离设计漏洞提供了一个有用的起点。 </p>
<p><img src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/the_art_of_security_assessment_translate/2-5.png" alt="2-5"></p>
<p>在准备实现审查时，你可以使用这些图来建模应用程序行为并隔离组件。例如，图2-6显示登录过程略有更改。你能看到漏洞在哪吗?登录过程处理无效登录的方式已经改变，因此它现在直接将每个阶段的结果返回给客户端。这个修改后的进程很容易受到攻击，因为攻击者可以在不成功登录的情况下识别有效的用户名，这在尝试对身份验证系统进行蛮力攻击时非常有用。</p>
<p><img src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/the_art_of_security_assessment_translate/2-6.png" alt="2-6"></p>
<p>通过绘制这个系统的图表，你可以更容易地识别它的安全组件。在本例中，它帮助你以系统身份验证的方式隔离漏洞。当然，登录示例仍然相当简单;更复杂的系统可能具有多个复杂层，必须封装在多个dfd中。你可能不希望对所有这些层进行建模，但是你应该分解不同的组件，直到达到与安全相关的考虑事项隔离的程度。幸运的是，有一些工具可以帮助这个过程。绘制图表的应用程序，如Microsoft Visio是有用的，而Microsoft威胁建模工具在此过程中尤其有用。 </p>
<h5 id="威胁识别"><a href="#威胁识别" class="headerlink" title="威胁识别"></a>威胁识别</h5><p>威胁识别是基于你对系统的了解来确定应用程序的安全暴露的过程。此阶段构建于您在前一阶段所做的工作之上，通过应用您的模型和对系统的理解来确定系统对外部实体的脆弱性。在这个阶段，你将使用一个称为攻击树(或威胁树)的新建模工具，它提供了一种标准化的方法来识别和记录系统中潜在的攻击向量。 </p>
<h6 id="画威胁树"><a href="#画威胁树" class="headerlink" title="画威胁树"></a>画威胁树</h6><p>攻击树的结构非常简单。它由一个根节点(描述攻击者的目标)和一系列子节点(指示实现目标的方法)组成。树的每一层都将这些步骤分解为更详细的内容，直到你对攻击者如何利用系统有了一个实际的了解。使用上一节中的简单Web应用程序示例，假设它用于存储个人信息。图2-7显示了此应用程序的高级攻击树。 </p>
<p><img src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/the_art_of_security_assessment_translate/2-7.png" alt="2-7"></p>
<p>如你所见，根节点位于顶部，下面有几个子节点。每个子节点都声明了一种攻击方法，可用于实现根节点中指定的目标。这个过程根据需要进一步分解为最终定义攻击的子节点。查看这个图，你应该开始注意攻击树和dfd之间的相似性。毕竟，攻击树不是在真空中开发的。最好的创建方法是遍历DFD并使用攻击树来记录特定的关注点。作为一个例子，请注意导致子节点1.2.1的分支如何遵循前面在分析有缺陷的登录过程的DFD时使用的相同推理模式。 </p>
<p>与dfd一样，你希望只沿着与安全相关的路径分解攻击树。你需要使用你的判断并确定哪些路径构成合理的攻击向量，哪些向量不太可能。但是，在进入这个主题之前，请继续下一节以获得对攻击树结构的更详细的描述。 </p>
<h6 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h6><p>你可能已经注意到在连接每个节点及其子节点的行中有一些奇怪的标记(例如节点1.2.1.1和1.2.1.2)。这些节点连接器之间的弧表示子节点是与(AND)节点，这意味着必须满足子节点的两个条件才能继续计算向量。没有弧的节点只是一个或(OR)节点，这意味着任何一个分支都可以在没有任何附加条件的情况下被遍历。参考图2-7，查看节点1.2.1中的蛮力登录。要遍历此节点，必须满足两个子节点中的以下条件: </p>
<ul>
<li>验证用户名</li>
<li>验证密码</li>
</ul>
<p>任何一个步骤都不能掠过。因此，节点1.2.1是一个AND节点。</p>
<p>相反的是，OR节点描述了一个目标可以通过任何一个子节点达到的情况。所以只有满足单个节点的条件才能继续计算子节点。 回到图2-7，看一下节点1.2的“作为目标用户登录”。这个目标可以通过两个方法之一实现：</p>
<ul>
<li>强制登陆</li>
<li>偷取用户证书</li>
</ul>
<p>作为用户登陆，只需要实现其中之一就可以。因此它们是OR节点。</p>
<h6 id="文本表示"><a href="#文本表示" class="headerlink" title="文本表示"></a>文本表示</h6><p>你可以用文本和图形表示攻击树。文本版本传递的信息与图形版本相同，但有时不太容易可视化(尽管它们更紧凑)。下面的例子展示了如何用文本格式表示图2-7中的攻击树: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1. 对方获得访问用户个人信息的权限</span><br><span class="line">	OR  1.1 获得直接访问数据库权限</span><br><span class="line">			1.1.1 利用系统应用或者内核的漏洞</span><br><span class="line">		1.2 作为目标用户登录</span><br><span class="line">			OR	1.2.1 蛮力登陆</span><br><span class="line">				AND 1.2.1.1 验证用户名</span><br><span class="line">					1.2.1.2 验证用户密码</span><br><span class="line">				1.2.2 窃取用户证书</span><br><span class="line">		1.3 劫持用户会话</span><br><span class="line">			窃取用户绘画cookie</span><br><span class="line">		1.4 被动截取个人资料</span><br><span class="line">			AND 1.4.1 验证用户连接初始化</span><br><span class="line">				1.4.2 嗅探网络流量中的个人数据</span><br></pre></td></tr></table></figure>

<p>如你所见，所有相同的信息都存在。首先，根节点目标被声明为攻击树的标题，它的直接后代在标题下面进行编号和缩进。每个新层都再次缩进，并以相同的方式在父节点下面编号。AND和或关键字用于指示节点是AND还是节点。</p>
<h6 id="威胁减轻"><a href="#威胁减轻" class="headerlink" title="威胁减轻"></a>威胁减轻</h6><p>攻击树的部分价值在于它允许你跟踪潜在的威胁。但是，如果无法确定如何减轻威胁，跟踪威胁就不是特别有用。幸运的是，攻击树包括一种特殊类型的节点来解决这个问题:循环节点。图2-8显示了一个带有适当缓解因素的示例攻击树。 </p>
<p><img src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/the_art_of_security_assessment_translate/2-8.png" alt="2-8"></p>
<p>在此攻击树中添加了三个缓解节点，以帮助你认识到这些向量与未缓解的分支相比，不太可能成为攻击的途径。在一个缓解节点中使用的虚线是一种将分支标识为不太可能的攻击向量的简写方法。它不会移除分支，但会鼓励你将注意力转移到其他地方。 </p>
<p>关于威胁减轻的最后一点注意事项:你不希望过早地去寻找它。识别缓解因素是有用的，因为它可以防止您追求一个不太可能的攻击向量。但是，你不希望陷入一种错误的安全感，从而错过一个可能的分支。因此，请仔细考虑缓解措施，并确保在将其添加到攻击树之前执行一些验证。 </p>
<h5 id="对寻找的结果进行文档记录"><a href="#对寻找的结果进行文档记录" class="headerlink" title="对寻找的结果进行文档记录"></a>对寻找的结果进行文档记录</h5><p>现在调查工作已经完成，你需要记录所发现的内容。在文档阶段，你将回顾在前一阶段发现的威胁，并以正式的方式呈现它们。对于你发现的每个威胁，你需要提供一个简短的总结，以及消除威胁的任何建议。要了解这个过程是如何工作的，请使用示例攻击树中的“蛮力登录”威胁(节点1.2.1)。这种威胁允许攻击者使用另一个用户的凭证登录。你的威胁总结文档将类似于表2-1。 </p>
<table>
<thead>
<tr>
<th>威胁</th>
<th>蛮力登陆</th>
</tr>
</thead>
<tbody><tr>
<td>受影响的组件</td>
<td>Web应用的登录组件</td>
</tr>
<tr>
<td>描述</td>
<td>客户端可以使用登录，通过反复地连接和尝试登陆攻击用户名和密码。这个威胁会因为应用会对不合法的用户名和密码返回不同地错误消息，使得用户名更容易被确认而增加。</td>
</tr>
<tr>
<td>造成结果</td>
<td>不可信的客户端可以得到用户的用户名，然后读取或者修改他们的敏感信息。</td>
</tr>
<tr>
<td>减轻危害的策略</td>
<td>使错误消息模糊，以至于攻击者不知道什么样的用户名和密码是不合法的。在用户账户多次登陆失败后锁定。（3-5次尝试比较适合）</td>
</tr>
</tbody></table>
<p>关于蛮力登录威胁的所有信息都整齐地总结在一个表中。在本阶段的下一部分，您将扩展此表，以包括关于威胁风险的一些附加信息。 </p>
<h5 id="风险评级"><a href="#风险评级" class="headerlink" title="风险评级"></a>风险评级</h5><p>与本章中的示例相比，实际应用程序在设计和实现方面通常要大得多，也更复杂。增加的大小和复杂性在各种用户类中创建了广泛的攻击向量。因此，你通常可以列出一长串的潜在威胁和可能的建议，以帮助减轻这些威胁。在一个完美的世界中，设计师可以系统地着手解决每一个威胁和潜在问题，必要时关闭每一个攻击向量。然而，某些业务现实可能不允许减少每个已确定的向量，而且几乎肯定不可能同时减少所有向量。显然，在担心那些不那么重要的风险之前，我们需要对一些更严重的风险进行优先排序。通过分配威胁严重程度评级，你可以根据每个未发现的威胁对应用程序和相关系统的安全性造成的风险对其进行排序。然后可以将此评级用作开发人员的指导方针，以帮助确定优先考虑哪些问题 。</p>
<p>你可以选择以多种不同的方式对威胁进行评级。最重要的是，你要考虑到威胁的暴露程度(利用的难易程度和载体的可用性)和在成功利用过程中所造成的伤害。除此之外，你可能希望添加与你的环境和业务流程更相关的组件。为了本章的威胁建模目的，使用了微软开发的恐惧评级系统。没有一个模型是完美的，但是这个模型在普遍接受的威胁特性之间提供了一个相当好的平衡。这些特点简述如下: </p>
<ul>
<li>潜在损伤。如果威胁被成功利用，会有什么后果? </li>
<li>再现性。再现问题中的攻击有多容易? </li>
<li>可利用程度。实施攻击的难度是多少？</li>
<li>受影响的用户。如果攻击已经成功实施，有哪些用户会被影响，以及这些用户有多重要?</li>
<li>发现的难度。发现这个漏洞难度有多大？</li>
</ul>
<p>每个类别都可以从1-10打分，1最低，10最高。 类别得分之和除以5作为整体威胁等级。3级或以下可视为低优先级威胁，4至7级为中等优先级威胁，8级或以上为高优先级威胁。 </p>
<h5 id="注-3"><a href="#注-3" class="headerlink" title="注"></a>注</h5><p>风险评级模型在给实现和操作漏洞上打分也非常有用。事实上，你可以使用风险评级模型作为你在整个过程中的审查通用评级系统。 </p>
<p>风险评级系统的好处之一是，它提供了一系列的细节，你可以在向业务决策者展示结果时使用。你可以给他们一个简明的威胁评估，只包括总的威胁等级和它所属的类别。你还可以提供更详细的信息，比如五个威胁类别的个人得分。你甚至可以给他们一份完整的报告，包括模型文档和你如何得到每个类别的分数的解释。不管你的选择是什么，在向客户或高级管理人员做演示时，最好在每个细节级别都有可用的信息。 </p>
<p>表2-2是一个对蛮力登录威胁的一个风险评级：</p>
<table>
<thead>
<tr>
<th>威胁</th>
<th>蛮力登录</th>
</tr>
</thead>
<tbody><tr>
<td>受影响的组件</td>
<td>Web应用的登录组件</td>
</tr>
<tr>
<td>描述</td>
<td>客户端可以使用蛮力登录，通过反复地连接和尝试登陆攻击用户名和密码。这个威胁会因为应用会对不合法的用户名和密码返回不同地错误消息，使得用户名更容易被确认而增加。</td>
</tr>
<tr>
<td>造成结果</td>
<td>不可信的客户端可以得到用户的用户名，然后读取或者修改他们的敏感信息。</td>
</tr>
<tr>
<td>减轻危害的策略</td>
<td>使错误消息模糊，以至于攻击者不知道什么样的用户名和密码是不合法的。在用户账户多次登陆失败后锁定。（3-5次尝试比较适合）</td>
</tr>
<tr>
<td>风险</td>
<td>潜在损伤： 6，再现性： 8</td>
</tr>
<tr>
<td></td>
<td>可利用性： 4， 受影响的用户： 5</td>
</tr>
<tr>
<td></td>
<td>可发现性：8</td>
</tr>
<tr>
<td></td>
<td>总：6.2</td>
</tr>
</tbody></table>
<h6 id="自动威胁模型文档"><a href="#自动威胁模型文档" class="headerlink" title="自动威胁模型文档"></a>自动威胁模型文档</h6><p>正如你所看到的，在威胁建模过程(包括文本和图表)中涉及到相当多的文档。幸运的是，Frank Swiderski(前面提到的威胁建模的合著者)开发了一个工具来帮助创建各种威胁建模文档。它可以在<a href="http://msdn.microsoft.com/security/securecode/threatmodeling/上免费下载。该工具可以轻松地创建dfd、用例、威胁摘要、资源摘要、实现假设和您将需要的许多其他文档。此外，文档被组织成易于导航和维护的树结构。该工具可以使用可扩展样式表语言转换" target="_blank" rel="noopener">http://msdn.microsoft.com/security/securecode/threatmodeling/上免费下载。该工具可以轻松地创建dfd、用例、威胁摘要、资源摘要、实现假设和您将需要的许多其他文档。此外，文档被组织成易于导航和维护的树结构。该工具可以使用可扩展样式表语言转换</a>(Extensible Stylesheet Language transformation, XSLT)处理将所有文档输出为HTML或您选择的其他输出形式。强烈建议你熟悉这个用于威胁建模文档的工具。 </p>
<h5 id="确定实施审查的优先次序"><a href="#确定实施审查的优先次序" class="headerlink" title="确定实施审查的优先次序"></a>确定实施审查的优先次序</h5><p>现在你已经完成了威胁总结并对其进行了评分，你终于可以将注意力转移到构建实现审查上了。在开发威胁模型时，你应该根据各种因素(包括模块、对象和功能)分解应用程序。这些划分应该反映在每个单独威胁摘要的受影响组件条目中。下一步是在适当的分解级别创建组件列表;确切地说，什么级别是由应用程序的大小、审阅人员的数量、可用的审阅时间以及类似的因素决定的。但是，通常最好从抽象的高层开始，因此只需要考虑几个组件。除了组件名称之外，你还需要在列表中另一列列出与每个组件相关联的风险得分。 </p>
<p>有了这个组件列表之后，你只需确定威胁摘要属于哪个组件，并将该摘要的风险得分添加到相关组件。在合计了汇总列表之后，你将获得与每个组件相关的风险评分。通常，你希望以最高分的部分开始你的评估，并继续从最高分到最低分的过程。由于时间、预算或其他限制，你可能还需要消除一些组件。所以最好从得分最低的部分开始剔除。你可以将此评分过程应用于下一级别的分解，在你拥有此组件列表之后，你只需确定威胁摘要属于哪个组件，并将该摘要的风险评分添加到相关组件即可。在合计了汇总列表之后，你将获得与每个组件相关的风险评分。通常，你希望以最高分的部分开始您的评估，并继续从最高分到最低分的过程。由于时间、预算或其他限制，你可能还需要消除一些组件。所以最好从得分最低的部分开始剔除。你可以将这个评分过程应用到大型应用程序的下一层分解;尽管这已经开始进入实施审查过程，这在第4章 “申请审查程序” 中会详述。</p>
<p>使用记分表可以让你更容易地对评审进行优先排序，特别是对于初学者来说。然而，这并不一定是完成工作的最佳方式。一个有经验的审核员通常能够根据他们对类似应用程序的理解对审查进行优先排序。理想情况下，这应该与威胁汇总得分一致，但有时情况并非如此。因此，将威胁总结考虑进去是很重要的，但当你有理由遵循更好的计划时，不要坚持使用它们。 </p>
<h4 id="6-2-5-总结"><a href="#6-2-5-总结" class="headerlink" title="6.2.5 总结"></a>6.2.5 总结</h4><p>本章探讨了应用程序设计审查的基本要素。你已经了解了安全性需要成为应用程序设计中的基本考虑因素，并了解了设计过程中的决策如何极大地影响应用程序的安全性。你同样也了解了一些用于理解应用程序设计的安全性和潜在漏洞的工具。 </p>
<p>重要的是，不要将设计审查过程视为一个孤立的组件。设计评审的结果应该自然地进展到在第4章讨论的实现审查过程中。 </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/05/the-art-of-software-security-assessment-Chap1-translate/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chenyu ZHU">
      <meta itemprop="description" content="Chenyu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chenyu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/05/the-art-of-software-security-assessment-Chap1-translate/" class="post-title-link" itemprop="url">the art of software security assessment Chap1. translate</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-05 23:08:39" itemprop="dateCreated datePublished" datetime="2020-06-05T23:08:39+08:00">2020-06-05</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="软件安全审计的艺术——识别以及预防软件的漏洞"><a href="#软件安全审计的艺术——识别以及预防软件的漏洞" class="headerlink" title="软件安全审计的艺术——识别以及预防软件的漏洞"></a>软件安全审计的艺术——识别以及预防软件的漏洞</h1><p>Translator: 山海(Chenyu ZHU)</p>
<p><em>注：翻译从原书6.软件安全审计概述（Introduction to Software Security Assessment）开始，前面的并不是正文内容。 ——By 译者</em></p>
<h2 id="第一部分：软件安全审计概述"><a href="#第一部分：软件安全审计概述" class="headerlink" title="第一部分：软件安全审计概述"></a>第一部分：软件安全审计概述</h2><h3 id="6-1-第一章：关于软件漏洞的基础知识"><a href="#6-1-第一章：关于软件漏洞的基础知识" class="headerlink" title="6.1 第一章：关于软件漏洞的基础知识"></a>6.1 第一章：关于软件漏洞的基础知识</h3><p><em>“任何足够高级的技术都与魔法难以区分”</em></p>
<p>——  亚瑟 C. 克拉克</p>
<h4 id="6-1-1-概论"><a href="#6-1-1-概论" class="headerlink" title="6.1.1 概论"></a>6.1.1 概论</h4><p>对软件技术缺乏理解的普通人倾向于将软件简单地看作一种像魔法一样的技术。一些软件在复杂度上决不输于任何硬件，但绝大多数人不会看到软件转动的轮子，听到它引擎的轰鸣声，或者拆开螺母和螺栓看看它是如何工作的。计算机软件早已经集成到我们的社会中，影响着几乎所有人日常生活的每一方面。人们对于软件的依赖性使得我们不得不面对它的安全问题。你无法忍住去了解什么样的软件能够保证你在使用它时是是安全的。你能怎样确认安全问题？软件安全失效又代表什么？</p>
<p>在这本书涵盖的课程中，你将会学习到如何去理解和评估软件安全性。你将会看到怎样结合理论和代码实践来进行安全审计。这个过程包括了怎样剖析应用程序，发现安全漏洞，评估每个漏洞表现出来的危险性。你还会学到怎样最大化利用你的时间，专注于一个程序中最与安全问题相关的部分然后优先找出最关键的漏洞。这些都是你理解一个程序安全审计所需要掌握的基础知识。</p>
<p>本章内容介绍软件漏洞的原理，并阐述违反软件系统安全原则的含义。你还能学到软件审计的基础，包括动机(<em>即为什么这么做 ——By 译者</em>)，审计的种类，以及审计如何配合软件开发进程。最后，一些能帮助你分类安全漏洞以及发现这些安全问题一般情况下是由什么原因造成的知识也会列出。</p>
<h4 id="6-1-2-漏洞"><a href="#6-1-2-漏洞" class="headerlink" title="6.1.2 漏洞"></a>6.1.2 漏洞</h4><p>现代软件就像魔法一样。一群<strong>专业团队</strong>花费超过十年的时间开发的复杂的软件可以立刻被黑客<strong>抬走</strong>。从第一眼看下来，这好像是不太可能的，就像魔法一样。然而， 当你透过帘子看它是如何运作的时候，这种奇妙的感觉就会消失。 总之，软件漏洞能让攻击者能轻松利用这些弱点以打成他们目的。在软件安全的语境下，漏洞的定义是一些软件的缺点与疏忽，这些缺点与疏忽能被攻击者恶意利用来干坏事，或者获取敏感信息，破坏以及摧毁一个系统，以及控制计算机系统以及程序。</p>
<p>这个定义和软件bug有点类似，bug是造成程序产生非预期结果的错误，过失与疏忽。很多程序员都吃过软件bug的亏。广义地来说，软件漏洞也是bug地一种。软件漏洞是能给你隐藏惊喜的bug(<em>surprise mother fucker? ——by 译者</em>)：恶意用户能够利用它们对软件与系统实施攻击，或者控制你的系统与程序。绝大多数软件漏洞都是软件bug，但仅仅有一部分bug能被算作安全漏洞。一个bug在被称为安全漏洞时，它必须造成与安全有关的影响。也就是说，它会允许攻击者做一些用户通常不会做的事。（这个主体会在接下来的章节继续提到，人们经常犯这种错误，将疏忽造成的安全问题当作bug）。</p>
<p>人们常说，安全是可靠性的一个子集。这可能不是一个宇宙级真理，但我们可以拿这句话做一个类比。一个可靠的程序相对来说bug会少很多：它很少在用户使用下崩溃，它能很好地处理异常条件。它通过“防御式”的方法开发出来所以能处理不确定的执行环境和不正确的输入。（<em>关于 ”防御式“ ，参见代码大全的防御式编程——by 译者<em>）安全程序具有鲁棒性(</em>robust</em>):它可以击退入侵者的集中攻击，这些入侵者试图操纵它的环境和输入，以便利用它达到某种邪恶的目的。软件安全性和可靠性也有相似的目标，因为它们都需要在开发策略上关注于消除软件缺陷。 </p>
<h5 id="注"><a href="#注" class="headerlink" title="注"></a>注</h5><p> 尽管将安全漏洞与软件bug进行比较是有用的，但有些漏洞并不那么清晰。例如，允许你编辑你不应该访问的关键系统文件的程序可能会根据其规范和设计完全正确地运行。所以它可能不属于大多数人对软件bug的定义，但它确实是一个安全漏洞。 </p>
<p> 攻击程序中的漏洞的过程称为利用（exploiting）。攻击者可能会利用漏洞，以一种聪明的方式运行程序，在程序运行时改变或监视程序的环境，或者如果程序本身就不安全，那就就简单地用这个程序达到预期目的。当攻击者使用外部程序或脚本执行攻击时，这个攻击程序通常被称为攻击脚本。 </p>
<h5 id="注-1"><a href="#注-1" class="headerlink" title="注"></a>注</h5><p>如前所述，攻击者可以利用漏洞来破坏系统的安全性。将“系统的安全性”概念化的一个有用方法是将系统的安全性看作是由安全策略定义的。从这个角度来看，当系统的安全策略被违反时，软件系统的安全性就会被破坏。</p>
<h5 id="注-2"><a href="#注-2" class="headerlink" title="注"></a>注</h5><p>加州大学戴维斯分校的计算机科学教授Matt Bishop在计算机漏洞领域已经有了很多年的研究。 他从正式的学术角度和技术角度对计算机安全进行了大量的思考。如果你对这些话题感兴趣，可以看看他的书《计算机安全:艺术与科学》 ( Bishop, M. Computer Security: Art &amp; Science. Addison-Wesley, 2003 ), 他的主页也奉上： <a href="http://nob.cs.ucdavis.edu/~bishop/" target="_blank" rel="noopener">http://nob.cs.ucdavis.edu/~bishop/</a> </p>
<p>对于由软件组成的系统，用户对应有安全政策，它简要指出了哪些能做哪些不能做。例如，这个政策可能会这样说：”未经身份验证的用户禁止使用日历服务。”如果未经身份验证的用户拥有访问日历服务的权限，那么这毫无疑问违反了安全政策。</p>
<p>每个软件系统都应该考虑自己的安全政策。它的形式可能是编写的文档，也可能是一个非正式的松散的期望集合，用户对在这个系统中怎么做是合理的有这样的期望。对于绝大多数软件系统，人们通常能懂得什么样的行为违反了安全规则，即使它没有在安全政策中被提及。因此，“安全政策”通常表示用户和社区对于什么行为是允许的，什么行为是禁止的所达成的共识。安全政策可以有如下所示的几种形式：</p>
<ul>
<li>对于特别敏感和具有严格限定作用域的系统，安全政策可以是通过数学学证明然后通过程序代码验证的规范约束。这种方法通常很昂贵，并且只适用受到严格控制的软件环境。比如信号灯，电梯，飞机等性命攸关的设备中所嵌入的系统能够通过这种验证。然而这种方法对于很多这样的应用程序也是非常昂贵且笨拙的。</li>
<li>安全政策可以是一个正式的书面条款。就像附录Q中阐述的“C.2信用卡信息应当永远不泄露给第三方或者未经充分加密后通过媒介传输。”这个条款可能来自于在开发过程中创建的关于软件的政策，也可能来自于与软件使用的资源相关的政策，例如网站的安全政策，操作系统政策或者数据库安全政策。</li>
<li>安全政策可以仅仅由非正式的，模糊的人们对合理程序安全行为所期望的集合构成。例如“让犯罪组织访问我们的信用卡数据库可能是不好的”。</li>
</ul>
<h5 id="注-3"><a href="#注-3" class="headerlink" title="注"></a>注</h5><p>Java虚拟机(Java Virtual Machine, JVM) 以及.Net公用语言运行库(Common Language Runtime, CLR)有不同程度的代码访问安全性(Code Access Security, CAS)。代码访问安全性提供了加载与运行时广泛的验证方法。这些验证包括字节码的完整性，软件的始发者以及代码访问限制的应用程序。这些技术最明显的应用包括Java applet和.NET管理的浏览器控件的沙箱环境。</p>
<p>尽管代码访问安全性可以用作严格的，形式化的安全模型的平台，但有些与之相关的注意事项必须要题。第一个问题就是大多数开发人员不完全了解它的应用和功能，因此商业软件中很少使用。第二个问题是代码访问安全性完全依赖于底层组件的安全性，JVM和.NET CLR都是漏洞的受害者，这些漏洞允许应用程序走出虚拟机沙箱并运行任意代码。</p>
<p>在实践中，软件系统的安全政策可能大部分都是由人们非正式的期望组成。然而，它经常来自开发过程和参考站点资源的正式文档的安全政策。系统安全政策这个定义有助于澄清“系统安全”这个概念。总之安全就是终端用户的需求和期望。</p>
<h5 id="安全期望"><a href="#安全期望" class="headerlink" title="安全期望"></a>安全期望</h5><p>考虑人们对软件安全可能有的期望有助于确定他们认为哪些行为是违反安全的。安全通常用三个部分来描述：保密性(avalability)，完整性(integrity)以及实用性(avalability).</p>
<h6 id="保密性"><a href="#保密性" class="headerlink" title="保密性"></a>保密性</h6><p>保密性要求信息私有(private). 在任何情况下，软件都应当做到隐藏信息或者隐藏信息的存在。软件系统经常要处理机密数据，比如国家级机密，公司的商业机密，甚至敏感的个人机密信息。</p>
<p>商业以及其他组织在软件中存储了很多机密信息。比如财务信息通常就是保密的。关于商业计划与业绩的信息更是战略级别的，这些信息对于非法竞争或者内幕交易等犯罪活动都可能有很大的用处。因此商业数据通常是要求保密性的。这些保密的商业数据包括商业关系，联系人，法律诉讼，或者其他需要保密的敏感信息。</p>
<p>一个软件系统处理信息时，出于隐私的考量，人们对保密的要求通常是很高的。组织以及个人用户都希望小心地把控哪些人能够访问这些信息。如果这些信息还包括财务数据或者医疗记录，不当的数据纰漏就可能涉及到责任问题。软件通常都想要对个人以及用户的信息保密，例如个人文件，邮箱，活动记录，账号和密码等。</p>
<p>在不同类型的软件中，机密是由软件代码构造出来的。比如一段用来评估市场上的潜在交易或者新的3D图形引擎的代码，尽管它不是交易机密，但它仍然是敏感的.比如评估贷款申请人信用风险的代码,或者在线视频游戏战斗系统背后的算法.</p>
<p>软件通常会将信息做一个划分,确保只有通过验证的用户允许访问授权过的信息.这个要求意味着软件通常需要使用访问权限控制技术来对用户在访问数据时进行验证.加密方法在数据传输与存储时也通常用于数据保密.</p>
<h6 id="完整性"><a href="#完整性" class="headerlink" title="完整性"></a>完整性</h6><p>完整性亦即数据的可信度与正确性.人们对软件有这样的要求,即拥有防止自己的数据被更改的能力.完整性不仅仅时对于数据的内容来讲,而且要包括数据的来源.有的软件可以通过记录一段数据的更改或者数据来源的更改来检测数据完整性的变化.</p>
<p>数据完整系通常包括了信息的划分,也就是软件使用访问权限控制技术验证用户是否拥有权限对数据进行更改.验证过程也是软件的一个重要组成部分,它能保护数据来源的完整性,因为它严格地告知了软件这个用户是谁.(<em>例如你通过了QQ密码验证, 就等于告诉了系统你是这个QQ的拥有者,你可以随便更改你的QQ信息 – By 译者</em>)</p>
<p>特别地,相比于保密性,用户对完整系也有类似的需求.任何允许攻击者修改他们本不允许修改的数据都的问题应该被视为一个安全漏洞.任何允许用户为章程其他用户并操纵数据的问题也应当被认定为对数据完整性的破坏.</p>
<p>软件在完整性方面的漏洞可以是毁灭性的.攻击者能够利用数据更改权限访问软件系统,并且得到它的控制权.</p>
<h6 id="实用性"><a href="#实用性" class="headerlink" title="实用性"></a>实用性</h6><p>实用性也就是使用信息以及资源的能力.一般来说, 它指的是用户对系统的可用性及其抵御拒绝服务攻击(denial-of-service DoS)的能力的期望。 </p>
<p>允许用户摧毁一个软件可以被认定为违反了实用性原则的漏洞.攻击者可以利用这个漏洞,使用一些特殊的输入或者环境破坏来通过消耗软件系统资源,例如CPU,硬盘存储,网络带宽等方式使一个程序无法运行.</p>
<h4 id="6-1-3-审计的必要性"><a href="#6-1-3-审计的必要性" class="headerlink" title="6.1.3 审计的必要性"></a>6.1.3 审计的必要性</h4><p>绝大多数人都希望供应商能够给他们的软件提供一定程度的对于完整性的保证.然而供应商在真实情况下几乎不给自己的软件提供质量保证.如果你对此表示怀疑,只要阅读下每个商业软件附带的几乎所有商业软件都适用的最终用户许可协议即可(end user license agreement ,EULA).当然,为了讨好用户,绝大多数供应商都会说自己对软件质量有自己的保障评估指标.这些评估指标往往出于市场考量,例如功能,实用性,一般的安全性.从历史上看,这使得安全性被随意地应用或者偶尔被完全忽略.</p>
<h5 id="注-4"><a href="#注-4" class="headerlink" title="注"></a>注</h5><p>一些产业确实出台了他们自己的安全要求和标准,但他们仅仅在特定的环境下进行使用.但这种做法正在改变.因为备受瞩目的时间正促使监管机构和行业标准机构转向为更加积极主动地对安全提出要求.</p>
<p>好消息是人们对于安全的态度近年来已经产生了改变,许多供应商已经在业务流程中开始使用严格地安全性测试.许多方法已经变得常见,比如自动代码分析,安全单元测试,手动代码审计等.从这标题你可以看出,这本书主要讨论手动代码审计.</p>
<p><strong>审计</strong>(auditing) 是一个分析代码的过程(无论这段代码是源代码还是二进制形式),这个过程用来发现一些可能被攻击者利用的漏洞.通过这个过程,你可以确认以及消除那些让敏感数据和商业资源陷入不必要风险的安全漏洞.</p>
<p> 除了公司开发内部软件的明显情况外，代码审计在其他一些情况下也有意义。 表1-1总结了最常见的审计方法:</p>
<table>
<thead>
<tr>
<th>审计形式</th>
<th>描述</th>
<th>优势</th>
</tr>
</thead>
<tbody><tr>
<td>内部软件审计(发布前)</td>
<td>软件公司在自己的新产品发布之前做的代码审计</td>
<td>漏洞能在产品进入市场前发现并填补,能节省开发和部署更新的费用,同时让公司免于潜在的骚扰</td>
</tr>
<tr>
<td>内部软件审计(发布后)</td>
<td>软件公司在产品发布之后进行审计</td>
<td>在恶意团队发现漏洞之前将其修复.这个过程可以花较长时间进行测设与检查而不是在漏洞暴露时匆忙发布</td>
</tr>
<tr>
<td>第三方产品范围比较</td>
<td>第三方拿相互竞争产品的某个方面进行审计</td>
<td>客观的第三方可以为消费者提供有价值的信息,并且帮助他们选择最安全的产品</td>
</tr>
<tr>
<td>第三方评估</td>
<td>第三方为客户对一个单独的软件进行审计</td>
<td>客户可以了解它正在考虑部署的应用程序的相对安全性。这可以为选择某个产品而不是其他提供相关参数的证明</td>
</tr>
<tr>
<td>第三方初步评估</td>
<td>第三方对一个还没有进入市场的产品进行评估</td>
<td>风险投资家可以了解未来技术在投资项目上的可行性.供应商也可以进行这种类型的评估,以确保它们所想要销售的产品的质量</td>
</tr>
<tr>
<td>独立研究</td>
<td>安全公司或咨询公司独立地执行软件审计</td>
<td>安全产品供应商可以识别扫描仪和其他安全设备的漏洞并实施保护措施。独立研究也起到行业监督的作用，为研究人员和安全公司提供了建立专业信誉的途径。</td>
</tr>
</tbody></table>
<p>正如你所看到的,代码审计在很多情况下都适用. 尽管具备这些技能的人员的需求大，但是，很少有专业人员具有高水平执行这些审计的培训和经验。我们希望这本书能帮助填补这一空白。 </p>
<h5 id="审计与黑盒测试"><a href="#审计与黑盒测试" class="headerlink" title="审计与黑盒测试"></a>审计与黑盒测试</h5><p><strong>黑盒测试</strong>(black box testing)是一种只通过操作软件所给的接口来评估软件的方法.特别地,这个过程更倾向于给一些精心设计的输入,这些输入能够让应用程序产生一些期望之外的结果,比如宕机或者暴露敏感数据.例如对一个HTTP服务器进行黑盒测试时可以向它发出一个字段大小异常大请求,这种请求可能造成内存崩溃的bug(在第五章”内存崩溃”我们会详细讨论).这个测试的请求可以是合法的,例如下面的内容:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET AAAAAAAAAAAAAAAAAAA...AAAAAAAAAAAAAAAAAAA HTTP&#x2F;1.0</span><br></pre></td></tr></table></figure>

<p>或者它也可以是非法请求,就像这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F; AAAAAAAAAAAAAAAAAAA...AAAAAAAAAAAAAAAAAAAA&#x2F;1.0</span><br></pre></td></tr></table></figure>

<p>任何这种请求导致的宕机都说明这个应用程序存在严重的bug.当考虑可以使用自动化测试应用程序的工具时,黑盒测试更有吸引力.这种自动化的黑盒测试被称为模糊测试(fuzz-testing). 而模糊测试工具包括通用的“dumb”和协议感知的“智能”fuzzer.因此你不需要手动地去尝试所有你可能想象的到的情况,你只要根据自己的设计运行这个这个工具然后收集结果就可以了.</p>
<p>黑盒测试的好处就是快,能迅速得到测试结果.然而,黑盒测试有几个非常关键的缺点.本质上说,黑盒测试就是丢一堆数据给应用程序然后看看他是不是做了一些设计者不想让他做的事情.你不知道这个过程中程序是如何处理数据的,所以有大量的不接触这些数据的代码你并没有进行探究.例如,回到这个web服务器的例子,假设请求的查询字符串中存在特定的关键词时它会具有特定的内部功能,就像下面的代码一样:请注意加粗的代码行(<em>Markdown代码块好像无法加粗,注意最后一个if语句即可 – by 译者</em>):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">keyval</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *key;</span><br><span class="line">    <span class="keyword">char</span> *value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">handle_query_string</span><span class="params">(<span class="keyword">char</span> *query_string)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">keyval</span> *<span class="title">qstring_values</span>, *<span class="title">ent</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">if</span>(!query_string)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    qstring_values = split_keyvalue_pairs(query_string);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>((ent = find_entry(qstring_values, <span class="string">"mode"</span>)) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">"MODE=%s"</span>, ent-&gt;value);</span><br><span class="line">        putenv(buf);</span><br><span class="line">    &#125;</span><br><span class="line">    ... more stuff here ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个web服务器有一个特殊的不规范的行为:如果查询字符串中含有 <code>mode=</code>,那么环境变量<code>MODE</code>就会被修改为<code>xxx</code>.这个特别的行为在实现上有一个缺陷,如果粗心地使用函数<code>sprintf()</code>就会造成缓冲区溢出.如果你不清楚为什么这段代码很危险,不必担心,缓冲区溢出漏洞会在第五章详细讨论.</p>
<p>从这个例子可以看出段存在bug的代码在黑盒测试中完全可能正常运行，简单的漏洞也无法探测出来。因此，你需要对程序代码本身进行评估而不是只靠跑几个测试例子然后记录结果就行。这也是代码审计很重要的原因。你需要能够分析代码然后发现自动测试工具无法探测到的漏洞。</p>
<p>幸运的是，代码审计配合黑盒测试能够利用最少的时间得到最好的修补漏洞的结果。这本书将会教会你这些知识和技术来彻底地分析一个应用程序方方面面的漏洞以及怎样应用你对这些知识的理解和创造力来发现一个应用程序的缺陷。</p>
<h5 id="代码审计与开发生命周期"><a href="#代码审计与开发生命周期" class="headerlink" title="代码审计与开发生命周期"></a>代码审计与开发生命周期</h5><p>当你考虑应用程序会暴露给潜在的恶意用户时，应用程序安全审计的重要性不言而喻。然而你需要明确知道什么时候进行审计。一般地，你可以在<strong>系统开发生命周期</strong>（Systems Developement Life Cycle， SDLC）的任何阶段进行审计。让么人，在什么时候进行审计所花费的代价是不一样的。因此在开始之前，我们先回顾一下系统开发生命周期的每个阶段：</p>
<ol>
<li><em>可行性研究</em>。这个阶段会考虑确认完成这个项目的需求并决定什么样的开发解决方案在技术上和预算上是合适的。</li>
<li><em>需求定义</em>。这个阶段将对于完成项目的需求进行更深入的研究，项目的目标也将确立。</li>
<li><em>设计</em>。设计解决方案来使得目标系统能够技术性地实现并且满足需求。</li>
<li><em>实现</em>。根据前面地设计阶段完成应用程序代码。</li>
<li><em>集成与测试</em>。解决方案要经过一定程度的质量保证，以确保它按预期工作，并捕获软件中的任何bug。</li>
<li><em>使用与维护</em>。解决方案发布并投入使用，然后根据用户地反馈进行修正，更新，更正。</li>
</ol>
<p>每个软件地开发过程都在某种程度上根据这套规则。经典的<strong>瀑布模型</strong>(waterfall models)要求系统周期严格地按照这个过程迭代一次。相反的是，新的方法论例如敏捷式软件开发(agile developement)更倾向于通过不断地迭代系统开发生命周期来改善程序。所以系统开发生命周期这个模型地应用是多样的，但基础的概念与阶段已经足够我们用于接下来地讨论。你可以用这些特点来帮助区分漏洞，在接下来的章节，你将会学到进行不同类别的审计的最佳阶段。 </p>
<h4 id="6-1-4-漏洞的分类"><a href="#6-1-4-漏洞的分类" class="headerlink" title="6.1.4 漏洞的分类"></a>6.1.4 漏洞的分类</h4><p>一个<strong>漏洞的类别</strong>（vulnerability class）是一系列拥有统一常见特征或者在不同软件缺陷中具有类似概念的漏洞的集合。当然，这个定义可能有点晦涩，但归根结底漏洞类别就是用来概念化软件缺陷的精神装置（mental device）。它们在我们理解问题以及将这种理解扩散到其他部分时大有帮助。但将漏洞分组到精确地不重叠的类中是不可能的。一个简单的漏洞很有可能根据代码审计者的术语，分类系统以及个人观点被分到许多类中。</p>
<p>这本书里不会使用一个对漏洞严格的形式化的分类，相反，这些问题会以一个一致的，实用的，适合于材料的方法进行分类。一些软件漏洞最好通过一些特殊的方法来处理。例如， 某些缺陷最好通过从高级软件组件的交互角度来看程序来解决 ； 另一种类型的缺陷最好通过将程序概念化为一系列系统调用来解决。无论采用哪种方法，本书都将解释你将在安全文献中遇到的术语和概念，以便你可以读懂安全社区在某种上下文中使用的一系列术语和分类方法。 </p>
<p>在定义一般漏洞类时， 你可以从SDLC阶段的讨论中得出一些一般性的区别。有两个漏洞的类别叫设计漏洞（SDLC 阶段1，2，3）和实现漏洞（SDLC阶段4，5） 。并且，这本书还会提到第三个类别：操作漏洞（operation vulnerability）（SDLC 阶段6）。安全社区通常将设计漏洞作为软件系统体系结构和规范中的缺陷，实现漏洞时软件系统实际构建过程中的技术缺陷。操作漏洞的类别则针对在特定环境中部署和配置软件时出现的缺陷。</p>
<h5 id="设计漏洞"><a href="#设计漏洞" class="headerlink" title="设计漏洞"></a>设计漏洞</h5><p><strong>设计漏洞</strong>来源于在软件设计时的根本的错误或者疏忽。由于设计缺陷的存在，软件本身就不会安全，因为软件做它被设计出来做得事，即错误的事情。这种缺陷时常出现， 因为对程序将在其中运行的环境所做的假设，或者程序组件在实际生产环境中所面临的暴露风险。 设计缺陷应当认定为高级别的漏洞，体系结构的缺陷，或者 程序需求或约束的问题。 </p>
<p>在SDLC的简要介绍中我们知道，软件系统的设计是依托于软件<strong>需求</strong>的定义的，这些需求是一系列软件系统所必须达到的目标。特别地， 工程师获取需求集并构造设计规范， 这些设计规范关注于如何创造满足这些需求的软件。 需求通常是软件系统必须完成的任务 。例如：“允许用户从服务器中检索事务文件”。需求也可以说明软件必须要用的功能，例如：“它必须支持每小时同时下载100个文件。”</p>
<p>设计规范就是怎样构建程序来实现预期需求的计划。特别地，它包括了一个软件系统不同组成部分地描述，这些部分如何实现的信息，以及各个组成部分如何交互的信息。设计规范可以包含结构图，逻辑关系图，进程流图，接口和协议说明书，类的继承层次关系，以及其他的技术性的说明书。</p>
<p>当人们说起设计缺陷，它们通常不会发现软件需求方面与软件规范方面缺陷的不同。这种不同一般难以发现因为很多高层次的问题可能是需求中的疏忽造成，也可能是规范中的错误造成。</p>
<p>举个例子，  TELNET 协议是被设计用来允许用户在远程机器中连接并像本地终端一样访问该机器。从设计的角度看，可以说TELNET具有一个依赖于非加密交流的漏洞。在一些环境中，如果底层网络是可信的，那么这种缺陷是可以接受的。然而，在企业网络和因特网中，非加密的交流就是一个大的缺陷，因为位于路由路径上的攻击者可以监视和劫持TELNET上的会话。如果管理者通过TELNET连接上了一个路由器然后输入了账号和密码，监视者就可以获得它们并将其记录。相反，像SSH这样的协议功能与TELNET几乎一样，但它能免于监视威胁因为所有交流信息都是经过加密的。</p>
<h5 id="实现漏洞"><a href="#实现漏洞" class="headerlink" title="实现漏洞"></a>实现漏洞</h5><p>在<strong>实现漏洞</strong>中，一份代码通常做到了他应该做的事情，但在运行操作的方式上它有安全隐患。顾名思义，这种问题通常在SDLC的实现阶段产生，但它经常被带入集成与测试阶段。如果在解决技术差异的实现过程偏离了原有设计，这种问题就有可能发生。然而，大多数情况是由软件构件时的技术工具，平台的细微差别以及语言环境造成的。实现漏洞通常也被称作低级别缺陷或者技术缺陷。</p>
<p>本书会给出很多关于实现漏洞的例子，因为发现这种技术缺陷是代码评审的基础操作之一。实现漏洞又包括了几种你可能听说过的广为人知的漏洞类，例如缓冲区溢出和资料隐码攻击(SQL injection)。</p>
<p>回到TELNET的例子，你能在TELNET的一些特定版本软件中找到实现漏洞。一些TELNET先前的版本不能正确地清理用户的环境变量，允许入侵者利用UNIX机器的动态连接特性提高他们在这台机器上的权限。还有一些缺陷允许入侵者制造缓冲区溢出，格式化字符串攻击各种版本的TELNET守护进程，通常这些操作都完全未经授权。这些缺陷导致攻击者能够在远处输入任何命令，就像是特权用户一样。基本上，攻击者可以对一个TELNET守护程序运行一个小小的攻击程序，然后立即在服务器上得到root权限。</p>
<h5 id="操作漏洞"><a href="#操作漏洞" class="headerlink" title="操作漏洞"></a>操作漏洞</h5><p><strong>操作漏洞</strong>是在特定环境中操作程序和软件的一般使用过程中出现的问题。一种区分出这种漏洞的方法就是这种漏洞并不是由于软件源代码源代码造成的，而是根植于软件如何与其运行环境。特别地，它们可以包括软件在其环境中的配置问题，支持软件和计算机的配置问题，由围绕系统的自动化和手动过程引起的问题。操作漏洞可以在用户系统中引起很多种类的攻击，例如社会工程和盗窃(social engineering and theft).这些问题一般发生在SDLC的使用与维护阶段，尽管它与继承和测试阶段也有一些重叠部分。</p>
<p>回到TELNET的例子，由于缺乏加密手段，它具有设计漏洞。假如你在寻找一个可以安全地实现自动化交易的软件系统。假设它需要每晚都要设定一系列权重参数来石英第二天的交易策略。更新这些数据的过程就是管理者在每个交易日的结尾通过TELNET登陆计算机，然后通过一个简单的应用程序输入新的变量集合。取决于环境，这个过程可能有很大的操作漏洞，因为在使用TELNET时有有非常多的风险，例如监视与登陆劫持。总之，维护软件的操作过程是有缺陷的，因为它使系统暴露于潜在的欺诈与攻击之下.</p>
<h5 id="灰色地带"><a href="#灰色地带" class="headerlink" title="灰色地带"></a>灰色地带</h5><p>从SDLC的视角看,设计漏洞和实现漏洞的区别非常简单.但事实不是总如此.许多实现漏洞同样可以解释为设计漏洞,因为在设计流程中并没有正确地预料到会有问题发生.另一方面,你也可以说软件系统低层次的部分也是以某种方式设计的.一个程序员可以在实现设计规范时设计软件的很多部分.这些部分可能包括一个类,一个函数,一个网络歇息,一个虚拟机,或者一系列巧妙的循环与分支.在缺乏严格的区分下,本书对设计漏洞是这样定义的:</p>
<p>通常情况下,设计漏洞是程序结构中高层次的问题,比如需求,基础接口,以及核心算法.</p>
<p>扩展一下设计漏洞的定义,本书使用如下定义来表示实现漏洞:</p>
<p>在低层次设计中的安全问题,例如一些独立的函数和类的问题就会被当作实现漏洞.实现漏洞当然也包括一些更复杂的但不在设计规范中提及的逻辑单元.(这些问题通常被称为逻辑漏洞).</p>
<p>同样的,操作漏洞和设计漏洞与实现漏洞之间也没有清晰的区别.比如一个程序在某个不安全的环境中下载了以后,你当然可以认为它是在设计与实现上有缺陷.你可以认为一个应用程序应当在开发出来后其安全性不依赖于所运行的环境.由于缺乏严格的区分,本书关于操作漏洞是这么定义的:</p>
<p>通常情况下,操作漏洞用于表示软件不安全的发布以及配置问题,不健全的管理以及围绕软件的管理实践,以及支持组件,比如比如应用程序和Web服务器的问题,以及对软件用户的直接攻击等问题.</p>
<p>你能看到对于设计,实现以及操作漏洞这三个概念有非常多的解释,所以不要认为这些定义是一个标记软件缺陷的可靠的正式的系统.它们只是用来学习软件漏洞的简单且有用的方法而已.</p>
<h4 id="常见的线索"><a href="#常见的线索" class="headerlink" title="常见的线索"></a>常见的线索</h4><p>在学习了一些关于审计过程,安全模型,异界三个常见的漏洞分类这些的背景知识后, 当你深入了解具体技术问题的细节时,本书将用剩下的篇幅继续讨论它们.现在,我们回过头来先看看隐藏在软件安全漏洞背后的一些常见线索,主要先关注一下漏洞最优可能在软件中出现的位置以及原因.</p>
<h5 id="输入与数据流"><a href="#输入与数据流" class="headerlink" title="输入与数据流"></a>输入与数据流</h5><p>大量的软件漏洞都来自于一个程序对有害数据处理时的预期之外的行为.所以第一格问题就是解决恶意数据时怎样被系统所接受并且造成了严重影响的.解释它的最好办法就是先从一个简单的缓冲区溢出漏洞的例子说起.</p>
<p>考虑一个UNIX程序,它包含了一个非常长的能造成缓冲区溢出的命令行变量.在这种情况下,恶意数据就是直接来自于攻击者通过命令行接口的输入.这个数据通过整个程序直到一些函数通过不安全的方式使用它,最后导致了受攻击的局面.</p>
<p>对于绝大多数漏洞,你都能发现一些攻击者往系统中注入一些恶意数据以触发攻击.然而,这些恶意数据可能通过比用户直接输入更迂回的方式发挥作用.这些数据可以来自不同的源头并且经过不同的接口.它也可以通过系统的多个部分,并在到达最终触发可以用条件的位置之前进行大量的修改. 因此，在检查软件系统时，需要考虑的最有用的属性之一是贯穿系统各个组件的数据流 .</p>
<p>例如,有一个应用可以处理大组织的会议日程表.在每个月结尾,这个应用都会生成一份本周起协调的所有会议的报告,包括一份对每个会议的简短总结.仔细检查代码就会发现,当应用程序创造这个总结时,大于1000个字符的会议描述会导致                        可以遭受攻击的缓冲区溢出的情况.</p>
<p>对这个漏洞进行攻击,你可以创建一个新的会议,他的描述性文字超过1000个字符,然后使用这个程序安排时间表.然后你就可以等待每个月的报告创建以后看看这个攻击时如何运转的.你的恶意数据可能通过几个系统的部分然后被存入数据库,同时避免被其他系统的用户发现.相应的,作为一个安全审查人员,你必须评估这个攻击向量的可行性.这个观点涉及分析会议描述的流程,从最初的创建,到多个应用程序的组件, 最后到在易受攻击的报告生成代码中使用。 这个跟踪数据流的过程是对软件设计和实现的审查的核心。用户可塑数据对系统构成严重威胁，跟踪端到端数据流是评估这种威胁的主要方法。通常，你必须确定用户可塑数据通过外部世界的接口(例如命令行或Web请求)进入系统的位置。然后，你要研究用户可塑数据在系统中传输的不同方式，同时查找任何可能利用这些数据的代码。数据很可能会通过软件系统的多个组件，并在其生命周期的几个点进行验证和操作。这个观点涉及分析会议描述的流程，从最初的创建，到多个应用程序组件，最后到在易受攻击的报告生成代码中使用。 </p>
<p>这个过程并不总是那么简单. 通常你会发现一段代码是很容易受到攻击的,但它最终是安全的,因为恶意输入的数据流在早以前就能被捕获或者过滤.通常情况下,这种攻击时通过偶然事件来组织的.例如开发认为处于完全与安全性无关的原因引入了一些代码,但这样的副作用就是在数据流的后期保护了易受攻击的组件.此外,跟踪真实应用程序中的数据流可能非常困难,复杂系统通常时有机地开发的,导致数据流高度碎片化.在处理单个用户的请求过程中,实际数据可能会遍历几十个组件,并出入于第三方代码框架中.</p>
<h5 id="信任关系"><a href="#信任关系" class="headerlink" title="信任关系"></a>信任关系</h5><p>软件系统中不同组件对彼此具有不同程度的信任,在分析给定软件系统的安全性时理解这些<strong>信任关系</strong>非常重要.信任关系对于数据流是不可或缺的,因为i组件 组件之间的信任级别通常决定了对它们之间交换的数据进行验证的数量。 </p>
<p>设计人员和开发人员通常认为两个组件之间的接口是可信的,或者将对等组件或者支持软件的组件指定为可信的.这意味着它们通常相信受信任的组件不会受到恶意干扰,并且它们认为对组建的数据和行为进行假设是安全的. 当然，如果这种信任是错位的，并且攻击者可以访问或操作受信任的实体，系统安全性就会像多米诺骨牌一样下降(<em>即一个部分不安全,其他地方由于传递效应也变得不安全 –by译者</em>)。 </p>
<p>说到多米诺骨牌，在评估系统中的信任关系时，理解信任的传递性非常重要。例如，如果你的软件系统信任某个特定的外部组件，而该组件又信任某个网络，那么你的系统就间接地信任了该网络。如果组件对网络的信任不佳，它可能会成为攻击的受害者，最终使你的软件处于危险之中。 </p>
<h5 id="假设与错位信任"><a href="#假设与错位信任" class="headerlink" title="假设与错位信任"></a>假设与错位信任</h5><p>看待软件缺陷的另一种有用的方法是,从程序员和设计人员在构建软件时做出毫无依据的假设的角度来考虑它们.开发人员可以在一个软件的许多方面做出错误的假设.包括输入数据的有效性和格式,支撑程序的安全性,环境中潜在的敌意,攻击者和用户的能力,甚至特定应用程序接口(API)的调用以及语言特性上的行为和细微差别.</p>
<p>不适当的假设与错位信任这两个概念密切相关,因为你可以说对组件进行不适当的信任与对组件进行毫无根据的假设非常相似,下面几节将讨论开发人员可能会以几种方式犯下与安全性相关的错误,这些错误就包括做出毫无根据的假设以及扩展不值得信任的内容.</p>
<h6 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h6><p>如前所述,大多数软件漏洞都是攻击者向软件系统注入恶意数据后出发的.这些数据之所以能造成这样的麻烦,原因之一就是软件往往过于信任与它通信的人,并且对数据的潜在来源和内容做了假设.(<em>即假设我不会输入恶意数据 –by 译者</em>)</p>
<p>具体说,当开发人员编写处理数据的代码时,它们经常对提供数据的用户或者软件组件做出假设.在处理用户输入时,开发人员通常认为用户不大可能做出这样的事情,比如输入一个包含5000字符的街道地址,期中还包含了无法打印出来的符号(<em>emoji里的抽象文字? – by译者</em>). 类似地,如果开发人员正在为两个软件组件之间编写接口代码,它们通常会假设输入格式是好的.例如,它们可能没有预料到程序在文件中防止一个负长度地二进制记录,或者发送一个40亿字节长的网络请求.</p>
<p>相反,攻击者在查看输入处理代码时,就试图考虑每一个可能导致不一致或者意外程序状态的输入.攻击者会试图探索软件的每一个可访问接口,并专门寻找开发人员所作的假设.对于攻击者来说,任何提供意外输入的机会都是宝贵的,因为这种输入通常会对开发人员没有预料到的后续处理产生微妙的影响.通常,如果你可以对软件运行时的属性进行以外的更改,那么你通常就可以找到一种方法来利用它对程序产生更大的(负面的)影响.</p>
<h6 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h6><p>接口就是软件各组件相互之间以及软件与外部世界进行通信的机制.许多漏洞时由于开发人员并没有充分认识到这些接口的安全属性,从而假设只有受信任的对等放可以使用它们而造成的.如果一个程序的组件可以通过网络或者本地机器上的各种机制访问,那么攻击者可能能直接列街道该组件并且输入恶意数据.如果编写该组件时假设其对等组件是可信的,则应用程序可能会以一种能够被利用攻击的方式错误地处理输入.</p>
<p>使得这个漏洞更加严重的是,开发人员通常错误地估计了攻击者到达这个接口地难度,因此他们信任这个接口,而这个接口是没有保证地.例如,开发人员可能认为自己的系统有很高的安全性,因为他们使用了带有自定义加密和专有的且复杂的网络协议.他们可能错误地认为攻击者不大可能构建自己爹客户端和加密层然后以意想不到的方式操纵协议. 不幸地是,这种假设非常不合理,因为许多攻击者在专有协议地逆向工程中找到了一种独特的乐趣.</p>
<p>总结一下,开发者可能由于以下原因对一个接口产生错位信任:</p>
<ul>
<li>他们选择了一种暴露接口的方法,这种方法不能提供足够的保护来抵御外来攻击者</li>
<li>他们选择了一种可靠的方法来公开接口,通常是操作系统的服务,但他们使用了错误的配置.攻击者还可能利用基础平台的漏洞获得对该接口的控制.</li>
<li>他们假设一个接口对于攻击者来说太难访问了,这是一个危险性极高的赌博.</li>
</ul>
<h5 id="环境的攻击"><a href="#环境的攻击" class="headerlink" title="环境的攻击"></a>环境的攻击</h5><p>软件系统不是在真空中运行的,他们在一个大的计算环境中作为程序来运行,这个计算环境包括操作系统,硬件架构,网络,文件系统,数据库以及用户.</p>
<p>尽管许多软件漏洞来自于恶意数据的处理过程,但有的软件漏洞是在攻击者更改软件所依赖的环境中发生的.这种缺陷可以当作一种对软件的底层环境所作的假设造成的漏洞.软件系统所依赖的每种支撑技术可能都有许多最佳实践和细微差别,如果应用程序开发人员没有完全了解每种技术的潜在安全问题,那么犯下一个导致安全暴露的错误就太容易了.</p>
<p>关于这个问题的一个经典的例子就是UNIX软件种常见的一个文件夹叫<code>/tmp</code>.当一个程序需要使用临时文件时,它会在系统公共目录中创建这个文件,一般它位于<code>/tmp</code>或者<code>var/tmp</code>.如果这个程序没有细心地编写,攻击者就可以预测程序地移动并在公共目录中设置陷阱.如果攻击者在正确的位置和正确的事件创建了一个符号连接,程序就会被欺骗,在系统其他地方以不同名称创建它的临时文件,如果易受攻击的程序以root权限运行,这通常就导致系统遭受攻击.</p>
<p>在这种情况下,漏洞不是通过攻击者提供给程序的数据触发的.相反,这是对程序运行时环境的攻击,导致程序与操作系统以一种预期之外以及不期望发生的方式进行交互.</p>
<h5 id="异常条件"><a href="#异常条件" class="headerlink" title="异常条件"></a>异常条件</h5><p>与处理异常情况相关的漏洞与数据和环境漏洞交织在一起。基本上，当攻击者可以通过外部手段(external measure)在程序的正常控制流中引起意外更改时，就会发生异常情况。这种行为可能导致程序的异步中断，例如信号的传递。它还可能涉及消耗全局系统资源来故意在程序的特定位置诱发故障条件。 </p>
<p>例如,如果一个进程试图写入一个关闭的网络连接或者通道,UNIX系统将发送一个 SIGPIPE信号,接收到此信号时的默认行为就是终止进程.攻击者可能会是一个易受攻击的程序在适当的时候对通道进行写入操作,然后应用程序能够成功执行写操作之前关闭通道,这将导致SIGPIPE信号,然后导致应用程序终止,并使得整个系统处于不稳定状态.对于更具体的示例,某些Linux发行版的网络文件系统(Network File System,NFS)状态守护进程很容易由于在正确的事件关闭连接而崩溃.利用这个漏洞能够破坏NFS功能,这种情况会持续到管理员可以干预并重置守护进程为止.</p>
<h4 id="6-1-6-总结"><a href="#6-1-6-总结" class="headerlink" title="6.1.6 总结"></a>6.1.6 总结</h4><p>在短短的这一章中已经涵盖了很多内容,当然可能还会留下一些问题.但无需担心,后续章节将会讨论更多细节,并在你的学习过程正给出答案.闲杂,重要的时要对计算机软件中可能出现的问题有很好的了解,并理解在讨论这些问题中所使用的术语.你还应该了解应用程序安全审计的必要性,并熟悉流程的不同方面.在后面的章节中,你将在此基础上学习如何使用这个审计过程来识别你所审查的应用程序中的漏洞.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Chenyu ZHU</p>
  <div class="site-description" itemprop="description">Chenyu</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">4</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/ChenyuZhuWhiskey" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ChenyuZhuWhiskey" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:chenyu_zhu@protonmail.com" title="E-Mail → mailto:chenyu_zhu@protonmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chenyu ZHU</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
