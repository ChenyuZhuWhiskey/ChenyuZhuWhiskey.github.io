<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="简易内核实现笔记(一) ——开启操作系统前的准备BIOS在计算机电源打开的一瞬间，x86架构的CPU处于实模式下，所谓的实模式就是8086CPU运行的模式，x86家族的CPU为了做到向下兼容，全部默认开机时运行在8086的模式下，在实模式中，所有的地址都是物理地址，寄存器大小都是16位，寻址采用20位地址线，由段地址左移4位+偏移地址实现。 在实模式背景下，第一行代码的位置是0xf000：0xff">
<meta property="og:type" content="article">
<meta property="og:title" content="简易内核实现笔记(一)">
<meta property="og:url" content="http://yoursite.com/2020/09/06/%E7%AE%80%E6%98%93%E5%86%85%E6%A0%B8%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0-%E4%B8%80/index.html">
<meta property="og:site_name" content="Chenyu&#39;s Blog">
<meta property="og:description" content="简易内核实现笔记(一) ——开启操作系统前的准备BIOS在计算机电源打开的一瞬间，x86架构的CPU处于实模式下，所谓的实模式就是8086CPU运行的模式，x86家族的CPU为了做到向下兼容，全部默认开机时运行在8086的模式下，在实模式中，所有的地址都是物理地址，寄存器大小都是16位，寻址采用20位地址线，由段地址左移4位+偏移地址实现。 在实模式背景下，第一行代码的位置是0xf000：0xff">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/kernel-note/01-descriptor.png">
<meta property="og:image" content="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/kernel-note/01-descriptor-type.png">
<meta property="og:image" content="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/kernel-note/01-page.png">
<meta property="article:published_time" content="2020-09-06T03:28:54.000Z">
<meta property="article:modified_time" content="2020-09-06T03:28:54.804Z">
<meta property="article:author" content="Chenyu ZHU">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/kernel-note/01-descriptor.png">

<link rel="canonical" href="http://yoursite.com/2020/09/06/%E7%AE%80%E6%98%93%E5%86%85%E6%A0%B8%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0-%E4%B8%80/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>简易内核实现笔记(一) | Chenyu's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Chenyu's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Aera of Pure Physics, Mathematics, Computer Science and Engineering</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/06/%E7%AE%80%E6%98%93%E5%86%85%E6%A0%B8%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0-%E4%B8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chenyu ZHU">
      <meta itemprop="description" content="Chenyu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chenyu's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          简易内核实现笔记(一)
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 11:28:54" itemprop="dateCreated datePublished" datetime="2020-09-06T11:28:54+08:00">2020-09-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="简易内核实现笔记-一-——开启操作系统前的准备"><a href="#简易内核实现笔记-一-——开启操作系统前的准备" class="headerlink" title="简易内核实现笔记(一) ——开启操作系统前的准备"></a>简易内核实现笔记(一) ——开启操作系统前的准备</h1><h2 id="BIOS"><a href="#BIOS" class="headerlink" title="BIOS"></a>BIOS</h2><p>在计算机电源打开的一瞬间，x86架构的CPU处于实模式下，所谓的实模式就是8086CPU运行的模式，x86家族的CPU为了做到向下兼容，全部默认开机时运行在8086的模式下，在实模式中，所有的地址都是物理地址，寄存器大小都是16位，寻址采用20位地址线，由段地址左移4位+偏移地址实现。</p>
<p>在实模式背景下，第一行代码的位置是0xf000：0xfff0，也就是0xffff0，这一行代码的指令是<code>jmp f000:e05b</code>,这个跳转的地址就是BIOS的第一行代码地址，随后BIOS就会进行硬件自检，在没有问题后就会执行最后一行代码<code>jmp 0x7c00</code>跳转到主引导程序MBR处。</p>
<h2 id="MBR"><a href="#MBR" class="headerlink" title="MBR"></a>MBR</h2><p>MBR占512字节，正好是一个硬盘扇区的大小，在这512字节的程序中，MBR的任务就是把加载器载入内存中执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">;主引导程序 </span><br><span class="line">;------------------------------------------------------------</span><br><span class="line">%include &quot;boot.inc&quot;</span><br><span class="line">SECTION MBR vstart&#x3D;0x7c00         </span><br><span class="line">   mov ax,cs      </span><br><span class="line">   mov ds,ax</span><br><span class="line">   mov es,ax</span><br><span class="line">   mov ss,ax</span><br><span class="line">   mov fs,ax</span><br><span class="line">   mov sp,0x7c00</span><br><span class="line">   mov ax,0xb800</span><br><span class="line">   mov gs,ax</span><br><span class="line"></span><br><span class="line">; 清屏</span><br><span class="line">;利用0x06号功能，上卷全部行，则可清屏。</span><br><span class="line">; -----------------------------------------------------------</span><br><span class="line">;INT 0x10   功能号:0x06	   功能描述:上卷窗口</span><br><span class="line">;------------------------------------------------------</span><br><span class="line">;输入：</span><br><span class="line">;AH 功能号&#x3D; 0x06</span><br><span class="line">;AL &#x3D; 上卷的行数(如果为0,表示全部)</span><br><span class="line">;BH &#x3D; 上卷行属性</span><br><span class="line">;(CL,CH) &#x3D; 窗口左上角的(X,Y)位置</span><br><span class="line">;(DL,DH) &#x3D; 窗口右下角的(X,Y)位置</span><br><span class="line">;无返回值：</span><br><span class="line">   mov     ax, 0600h</span><br><span class="line">   mov     bx, 0700h</span><br><span class="line">   mov     cx, 0                   ; 左上角: (0, 0)</span><br><span class="line">   mov     dx, 184fh		   ; 右下角: (80,25),</span><br><span class="line">				   ; 因为VGA文本模式中，一行只能容纳80个字符,共25行。</span><br><span class="line">				   ; 下标从0开始，所以0x18&#x3D;24,0x4f&#x3D;79</span><br><span class="line">   int     10h                     ; int 10h</span><br><span class="line"></span><br><span class="line">   ; 输出字符串:MBR</span><br><span class="line">   mov byte [gs:0x00],&#39;1&#39;</span><br><span class="line">   mov byte [gs:0x01],0xA4</span><br><span class="line"></span><br><span class="line">   mov byte [gs:0x02],&#39; &#39;</span><br><span class="line">   mov byte [gs:0x03],0xA4</span><br><span class="line"></span><br><span class="line">   mov byte [gs:0x04],&#39;M&#39;</span><br><span class="line">   mov byte [gs:0x05],0xA4	   ;A表示绿色背景闪烁，4表示前景色为红色</span><br><span class="line"></span><br><span class="line">   mov byte [gs:0x06],&#39;B&#39;</span><br><span class="line">   mov byte [gs:0x07],0xA4</span><br><span class="line"></span><br><span class="line">   mov byte [gs:0x08],&#39;R&#39;</span><br><span class="line">   mov byte [gs:0x09],0xA4</span><br><span class="line">	 </span><br><span class="line">   mov eax,LOADER_START_SECTOR	 ; 起始扇区lba地址</span><br><span class="line">   mov bx,LOADER_BASE_ADDR       ; 写入的地址</span><br><span class="line">   mov cx,4			 ; 待读入的扇区数</span><br><span class="line">   call rd_disk_m_16		 ; 以下读取程序的起始部分（一个扇区）</span><br><span class="line">  </span><br><span class="line">   jmp LOADER_BASE_ADDR + 0x300</span><br><span class="line">       </span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">;功能:读取硬盘n个扇区</span><br><span class="line">rd_disk_m_16:	   </span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">				       ; eax&#x3D;LBA扇区号</span><br><span class="line">				       ; ebx&#x3D;将数据写入的内存地址</span><br><span class="line">				       ; ecx&#x3D;读入的扇区数</span><br><span class="line">      mov esi,eax	  ;备份eax</span><br><span class="line">      mov di,cx		  ;备份cx</span><br><span class="line">;读写硬盘:</span><br><span class="line">;第1步：设置要读取的扇区数</span><br><span class="line">      mov dx,0x1f2</span><br><span class="line">      mov al,cl</span><br><span class="line">      out dx,al            ;读取的扇区数</span><br><span class="line"></span><br><span class="line">      mov eax,esi	   ;恢复ax</span><br><span class="line"></span><br><span class="line">;第2步：将LBA地址存入0x1f3 ~ 0x1f6</span><br><span class="line"></span><br><span class="line">      ;LBA地址7~0位写入端口0x1f3</span><br><span class="line">      mov dx,0x1f3                       </span><br><span class="line">      out dx,al                          </span><br><span class="line"></span><br><span class="line">      ;LBA地址15~8位写入端口0x1f4</span><br><span class="line">      mov cl,8</span><br><span class="line">      shr eax,cl</span><br><span class="line">      mov dx,0x1f4</span><br><span class="line">      out dx,al</span><br><span class="line"></span><br><span class="line">      ;LBA地址23~16位写入端口0x1f5</span><br><span class="line">      shr eax,cl</span><br><span class="line">      mov dx,0x1f5</span><br><span class="line">      out dx,al</span><br><span class="line"></span><br><span class="line">      shr eax,cl</span><br><span class="line">      and al,0x0f	   ;lba第24~27位</span><br><span class="line">      or al,0xe0	   ; 设置7～4位为1110,表示lba模式</span><br><span class="line">      mov dx,0x1f6</span><br><span class="line">      out dx,al</span><br><span class="line"></span><br><span class="line">;第3步：向0x1f7端口写入读命令，0x20 </span><br><span class="line">      mov dx,0x1f7</span><br><span class="line">      mov al,0x20                        </span><br><span class="line">      out dx,al</span><br><span class="line"></span><br><span class="line">;第4步：检测硬盘状态</span><br><span class="line">  .not_ready:</span><br><span class="line">      ;同一端口，写时表示写入命令字，读时表示读入硬盘状态</span><br><span class="line">      nop</span><br><span class="line">      in al,dx</span><br><span class="line">      and al,0x88	   ;第4位为1表示硬盘控制器已准备好数据传输，第7位为1表示硬盘忙</span><br><span class="line">      cmp al,0x08</span><br><span class="line">      jnz .not_ready	   ;若未准备好，继续等。</span><br><span class="line"></span><br><span class="line">;第5步：从0x1f0端口读数据</span><br><span class="line">      mov ax, di</span><br><span class="line">      mov dx, 256</span><br><span class="line">      mul dx</span><br><span class="line">      mov cx, ax	   ; di为要读取的扇区数，一个扇区有512字节，每次读入一个字，</span><br><span class="line">			   ; 共需di*512&#x2F;2次，所以di*256</span><br><span class="line">      mov dx, 0x1f0</span><br><span class="line">  .go_on_read:</span><br><span class="line">      in ax,dx</span><br><span class="line">      mov [bx],ax</span><br><span class="line">      add bx,2		  </span><br><span class="line">      loop .go_on_read</span><br><span class="line">      ret</span><br><span class="line"></span><br><span class="line">   times 510-($-$$) db 0</span><br><span class="line">   db 0x55,0xaa</span><br></pre></td></tr></table></figure>
<p>可以看到MBR的代码分为两部分，第一个部分就是在窗口打印”1 MBR”这几个字符，这是通过向段起始0xb800处的内存写入字符实现的。在实模式下，这个地址就是显存的位置。第二部分就是写入loader，也就是函数<code>rd_disk_m_16</code>，在这个函数里，<code>cx</code>寄存器储存的是要读的磁盘扇区个数。相关的宏定义如下：</p>
<p>宏<code>LOADER_START_SECTOR</code>就是0x2，表示我们要向磁盘第三个扇区（第一个是0x0）读loader，<code>LOADER_BASE_ADDR</code>就是loader被写入的地址0x900。</p>
<p>在加载完loader之后，MBR的使命就结束了，最后一条命令<code>jmpLOADER_BASE_ADDR+0x300</code>就是跳转到loader的第一条命令去执行loader。</p>
<h2 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h2><p>我们的loader就负责做四个事情：</p>
<ul>
<li>加载全局描述符表 </li>
<li>进入保护模式</li>
<li>创建页表，展开虚拟地址空间</li>
<li>加载操作系统内核</li>
</ul>
<h3 id="保护模式"><a href="#保护模式" class="headerlink" title="保护模式"></a>保护模式</h3><p>所谓的保护模式就是可以寻址32位（4GB）的模式，而’保护’二字指的就是在这个模式下CPU为程序执行提供了一些内存的保护措施，这个措施就是通过全局描述符表来实现的。为了开启保护模式，我们要做3件事：</p>
<ul>
<li>加载全局描述符表</li>
<li>打开A20 Gate</li>
<li>修改控制寄存器CR0第一位为1</li>
</ul>
<h4 id="全局描述符表"><a href="#全局描述符表" class="headerlink" title="全局描述符表"></a>全局描述符表</h4><p>全局描述符表就是一个表，存储着段描述符，所谓的描述符就是关于内存段的一些信息，CPU会根据这些信息做出相应的措施，所谓的全局就是指这个表不是局部的。一个描述符占了64位8字节，每位的意义如下：</p>
<p><img src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/kernel-note/01-descriptor.png" alt="descriptor"></p>
<p>由于一些向下兼容的原因，一些东西是不连续的，但不妨碍我们理解：</p>
<ul>
<li>段界限：一个段的最大大小是20位，如果索引超过段界限CPU会触发异常。</li>
<li>G：段界限的粒度，如果G为0就代表粒度是1位，对应到段界限就是20位1MB。G为1就代表粒度为4KB，对应到段界限就是4GB，因此实际的段界限大小等=粒度大小*段界限-1</li>
<li>段基址：顾名思义，不用说了</li>
<li>D/B：一个用来兼容80286保护模式的位，表示有效地址和操作数的位数。D为0表示16位，D为1表示32位（所以对我们不用80286的就没什么用）</li>
<li>L：为1表示64位代码段，0表示32位</li>
<li>AVL：available字段，这个available是对于用户来说的，不是硬件，所以是可以随便用的</li>
<li>P：用于指示段是否存在于内存中，用到这个段时如果它不存在，就会触发CPU的异常，然后跳转到异常处理程序中把它加载到内存中。</li>
<li>DPL：表示特权级，特权级一共4级，从高到低为0，1，2，3。</li>
<li>S：为1表示系统段，0表示非系统段</li>
<li>type：段的类型，这三位对于系统段和非系统段有不同的定义：</li>
</ul>
<p><img src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/kernel-note/01-descriptor-type.png" alt="descriptor-type"></p>
<h4 id="A20-Gate"><a href="#A20-Gate" class="headerlink" title="A20 Gate"></a>A20 Gate</h4><p>实模式能够寻址的空间是1MB 20位，要进入保护模式的32位寻址，就要去除20位寻址的限制，这个限制被称为A20 Gate，打开A20 Gate的方法就是将端口0x92的第一个位置写为1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in al,0x92</span><br><span class="line">or al,0000_0010B</span><br><span class="line">out 0x92,al</span><br></pre></td></tr></table></figure>
<p>而进入保护模式的方法就是将控制寄存器CR0的第0位写为1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax, cr0</span><br><span class="line">or eax, 0x00000001</span><br><span class="line">mov cr0, eax</span><br></pre></td></tr></table></figure>
<p>因此，进入保护模式的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">;-----------------   准备进入保护模式   -------------------</span><br><span class="line">;1 打开A20</span><br><span class="line">;2 加载gdt</span><br><span class="line">;3 将cr0的pe位置1</span><br><span class="line"></span><br><span class="line">   ;-----------------  打开A20  ----------------</span><br><span class="line">   in al,0x92</span><br><span class="line">   or al,0000_0010B</span><br><span class="line">   out 0x92,al</span><br><span class="line"></span><br><span class="line">   ;-----------------  加载GDT  ----------------</span><br><span class="line">   lgdt [gdt_ptr]</span><br><span class="line"></span><br><span class="line">   ;-----------------  cr0第0位置1  ----------------</span><br><span class="line">   mov eax, cr0</span><br><span class="line">   or eax, 0x00000001</span><br><span class="line">   mov cr0, eax</span><br><span class="line"></span><br><span class="line">   jmp dword SELECTOR_CODE:p_mode_start	     ; 刷新流水线，避免分支预测的影响,这种cpu优化策略，最怕jmp跳转，</span><br><span class="line">					     ; 这将导致之前做的预测失效，从而起到了刷新的作用。</span><br><span class="line">.error_hlt:		      ;出错则挂起</span><br><span class="line">   hlt</span><br></pre></td></tr></table></figure>
<h3 id="虚拟地址空间"><a href="#虚拟地址空间" class="headerlink" title="虚拟地址空间"></a>虚拟地址空间</h3><p>在进入保护模式之后，我们所访问的32位地址仍然是物理地址，虚拟地址为我们提供了一层抽象，使得每个进程都可以在32位地址空间中运行，我们只需要通过页表将它们映射到物理地址即可，这样写程序就不用再自己去管地址从哪里开始了。</p>
<h4 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h4><p>页表是虚拟地址与物理地址的映射关系，由于将来每个操作系统下的进程，包括操作系统自己都是在32位虚拟地址空间中运行的，因此每个进程都需要有自己的页表，我们将物理地址分页，每个页占有4kB的大小，一个页表项就占32位4字节，检索4GB的虚拟内存空间总共需要1M个页表，在内存中占4MB，这个大小显然是无法接受的，因此我们再创建一个页表的页表，也就是页目录表，一个页目录项也是32位4字节，因此一个页目录项也可以索引4kB的空间，那么检索4GB的虚拟地址空间只需要4GB/4kB/4kB=1024个页目录，只需要4096个字节就可以了，这样的开销就可以接受。</p>
<p>对于1024个页目录，我们需要10位地址来进行索引，这10位地址就是虚拟地址中的高10位，我们将这10位地址*4就是对应页表的偏移地址，再加上页目录表的起始地址就得到了对应页表所在的物理地址，一个页表中有1024个页，因此检索它也需要10位地址，这10位地址就是虚拟地址中的中间10位，我们用这中间10位地址*4就得到了所在页的偏移地址，加上前面得到的页表物理地址就得到了对应页所在物理地址，这个页中存储的就是真实物理地址的偏移量，再加上最低12位虚拟地址就得到了对应的真实物理地址了。</p>
<p>因为每个页表项都是4字节，因此它们的值里面低12位全是0，因此为了避免浪费就要往里面加一些关于页表的安全信息：</p>
<p><img src="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/kernel-note/01-page.png" alt="page"></p>
<p>其中：</p>
<ul>
<li>P：该页存在于物理地址中</li>
<li>R/W：读写权限，0表示只读，1表示可读可写</li>
<li>US：普通用户/超级用户位，为1表示在普通用户级，普通用户在特权级3</li>
<li>PWT：通写位，1表示处于通写模式，表示改该页是高速缓存</li>
<li>PCD：打开使用高速缓存</li>
<li>A:访问位，如果CPU访问过该页，就会把它置为1，之后的操作系统我们会将它置为0，通过count置为1的次数就能判断它是否常常被使用，是就将这个页存入缓存中</li>
<li>D：脏页位，CPU对一个页进行写操作时，就会把这个位置为1，仅对页表项有效</li>
<li>G：global位，若为global，那么这个页表就会一直在高速缓存TLB中保存</li>
<li>AVL：软件的可用为，CPU不会管，怎么用就是软件定义的了</li>
</ul>
<p>对页表的初始化我们要有一个约定，也就是4GB的虚拟地址空间中，高1GB是只有操作系统内核才能访问的区域，因此在初始化页表时我们要将内核区的页表和普通页表分开，并且为了减小开销在未来将所有进程的内核页表通用，所以完整的loader代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br></pre></td><td class="code"><pre><span class="line">   %include &quot;boot.inc&quot;</span><br><span class="line">   section loader vstart&#x3D;LOADER_BASE_ADDR</span><br><span class="line">;构建gdt及其内部的描述符</span><br><span class="line">   GDT_BASE:   dd    0x00000000 </span><br><span class="line">	       dd    0x00000000</span><br><span class="line"></span><br><span class="line">   CODE_DESC:  dd    0x0000FFFF </span><br><span class="line">	       dd    DESC_CODE_HIGH4</span><br><span class="line"></span><br><span class="line">   DATA_STACK_DESC:  dd    0x0000FFFF</span><br><span class="line">		     dd    DESC_DATA_HIGH4</span><br><span class="line"></span><br><span class="line">   VIDEO_DESC: dd    0x80000007	       ; limit&#x3D;(0xbffff-0xb8000)&#x2F;4k&#x3D;0x7</span><br><span class="line">	       dd    DESC_VIDEO_HIGH4  ; 此时dpl为0</span><br><span class="line"></span><br><span class="line">   GDT_SIZE   equ   $ - GDT_BASE</span><br><span class="line">   GDT_LIMIT   equ   GDT_SIZE -	1 </span><br><span class="line">   times 60 dq 0					 ; 此处预留60个描述符的空位(slot)</span><br><span class="line">   SELECTOR_CODE equ (0x0001&lt;&lt;3) + TI_GDT + RPL0         ; 相当于(CODE_DESC - GDT_BASE)&#x2F;8 + TI_GDT + RPL0</span><br><span class="line">   SELECTOR_DATA equ (0x0002&lt;&lt;3) + TI_GDT + RPL0	 ; 同上</span><br><span class="line">   SELECTOR_VIDEO equ (0x0003&lt;&lt;3) + TI_GDT + RPL0	 ; 同上 </span><br><span class="line"></span><br><span class="line">   ; total_mem_bytes用于保存内存容量,以字节为单位,此位置比较好记。</span><br><span class="line">   ; 当前偏移loader.bin文件头0x200字节,loader.bin的加载地址是0x900,</span><br><span class="line">   ; 故total_mem_bytes内存中的地址是0xb00.将来在内核中咱们会引用此地址</span><br><span class="line">   total_mem_bytes dd 0					 </span><br><span class="line">   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span><br><span class="line"></span><br><span class="line">   ;以下是定义gdt的指针，前2字节是gdt界限，后4字节是gdt起始地址</span><br><span class="line">   gdt_ptr  dw  GDT_LIMIT </span><br><span class="line">	    dd  GDT_BASE</span><br><span class="line"></span><br><span class="line">   ;人工对齐:total_mem_bytes4字节+gdt_ptr6字节+ards_buf244字节+ards_nr2,共256字节</span><br><span class="line">   ards_buf times 244 db 0</span><br><span class="line">   ards_nr dw 0		      ;用于记录ards结构体数量</span><br><span class="line"></span><br><span class="line">   loader_start:</span><br><span class="line">   </span><br><span class="line">;-------  int 15h eax &#x3D; 0000E820h ,edx &#x3D; 534D4150h (&#39;SMAP&#39;) 获取内存布局  -------</span><br><span class="line"></span><br><span class="line">   xor ebx, ebx		      ;第一次调用时，ebx值要为0</span><br><span class="line">   mov edx, 0x534d4150	      ;edx只赋值一次，循环体中不会改变</span><br><span class="line">   mov di, ards_buf	      ;ards结构缓冲区</span><br><span class="line">.e820_mem_get_loop:	      ;循环获取每个ARDS内存范围描述结构</span><br><span class="line">   mov eax, 0x0000e820	      ;执行int 0x15后,eax值变为0x534d4150,所以每次执行int前都要更新为子功能号。</span><br><span class="line">   mov ecx, 20		      ;ARDS地址范围描述符结构大小是20字节</span><br><span class="line">   int 0x15</span><br><span class="line">   jc .e820_failed_so_try_e801   ;若cf位为1则有错误发生，尝试0xe801子功能</span><br><span class="line">   add di, cx		      ;使di增加20字节指向缓冲区中新的ARDS结构位置</span><br><span class="line">   inc word [ards_nr]	      ;记录ARDS数量</span><br><span class="line">   cmp ebx, 0		      ;若ebx为0且cf不为1,这说明ards全部返回，当前已是最后一个</span><br><span class="line">   jnz .e820_mem_get_loop</span><br><span class="line"></span><br><span class="line">;在所有ards结构中，找出(base_add_low + length_low)的最大值，即内存的容量。</span><br><span class="line">   mov cx, [ards_nr]	      ;遍历每一个ARDS结构体,循环次数是ARDS的数量</span><br><span class="line">   mov ebx, ards_buf </span><br><span class="line">   xor edx, edx		      ;edx为最大的内存容量,在此先清0</span><br><span class="line">.find_max_mem_area:	      ;无须判断type是否为1,最大的内存块一定是可被使用</span><br><span class="line">   mov eax, [ebx]	      ;base_add_low</span><br><span class="line">   add eax, [ebx+8]	      ;length_low</span><br><span class="line">   add ebx, 20		      ;指向缓冲区中下一个ARDS结构</span><br><span class="line">   cmp edx, eax		      ;冒泡排序，找出最大,edx寄存器始终是最大的内存容量</span><br><span class="line">   jge .next_ards</span><br><span class="line">   mov edx, eax		      ;edx为总内存大小</span><br><span class="line">.next_ards:</span><br><span class="line">   loop .find_max_mem_area</span><br><span class="line">   jmp .mem_get_ok</span><br><span class="line"></span><br><span class="line">;------  int 15h ax &#x3D; E801h 获取内存大小,最大支持4G  ------</span><br><span class="line">; 返回后, ax cx 值一样,以KB为单位,bx dx值一样,以64KB为单位</span><br><span class="line">; 在ax和cx寄存器中为低16M,在bx和dx寄存器中为16MB到4G。</span><br><span class="line">.e820_failed_so_try_e801:</span><br><span class="line">   mov ax,0xe801</span><br><span class="line">   int 0x15</span><br><span class="line">   jc .e801_failed_so_try88   ;若当前e801方法失败,就尝试0x88方法</span><br><span class="line"></span><br><span class="line">;1 先算出低15M的内存,ax和cx中是以KB为单位的内存数量,将其转换为以byte为单位</span><br><span class="line">   mov cx,0x400	     ;cx和ax值一样,cx用做乘数</span><br><span class="line">   mul cx </span><br><span class="line">   shl edx,16</span><br><span class="line">   and eax,0x0000FFFF</span><br><span class="line">   or edx,eax</span><br><span class="line">   add edx, 0x100000 ;ax只是15MB,故要加1MB</span><br><span class="line">   mov esi,edx	     ;先把低15MB的内存容量存入esi寄存器备份</span><br><span class="line"></span><br><span class="line">;2 再将16MB以上的内存转换为byte为单位,寄存器bx和dx中是以64KB为单位的内存数量</span><br><span class="line">   xor eax,eax</span><br><span class="line">   mov ax,bx		</span><br><span class="line">   mov ecx, 0x10000	;0x10000十进制为64KB</span><br><span class="line">   mul ecx		;32位乘法,默认的被乘数是eax,积为64位,高32位存入edx,低32位存入eax.</span><br><span class="line">   add esi,eax		;由于此方法只能测出4G以内的内存,故32位eax足够了,edx肯定为0,只加eax便可</span><br><span class="line">   mov edx,esi		;edx为总内存大小</span><br><span class="line">   jmp .mem_get_ok</span><br><span class="line"></span><br><span class="line">;-----------------  int 15h ah &#x3D; 0x88 获取内存大小,只能获取64M之内  ----------</span><br><span class="line">.e801_failed_so_try88: </span><br><span class="line">   ;int 15后，ax存入的是以kb为单位的内存容量</span><br><span class="line">   mov  ah, 0x88</span><br><span class="line">   int  0x15</span><br><span class="line">   jc .error_hlt</span><br><span class="line">   and eax,0x0000FFFF</span><br><span class="line">      </span><br><span class="line">   ;16位乘法，被乘数是ax,积为32位.积的高16位在dx中，积的低16位在ax中</span><br><span class="line">   mov cx, 0x400     ;0x400等于1024,将ax中的内存容量换为以byte为单位</span><br><span class="line">   mul cx</span><br><span class="line">   shl edx, 16	     ;把dx移到高16位</span><br><span class="line">   or edx, eax	     ;把积的低16位组合到edx,为32位的积</span><br><span class="line">   add edx,0x100000  ;0x88子功能只会返回1MB以上的内存,故实际内存大小要加上1MB</span><br><span class="line"></span><br><span class="line">.mem_get_ok:</span><br><span class="line">   mov [total_mem_bytes], edx	 ;将内存换为byte单位后存入total_mem_bytes处。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;-----------------   准备进入保护模式   -------------------</span><br><span class="line">;1 打开A20</span><br><span class="line">;2 加载gdt</span><br><span class="line">;3 将cr0的pe位置1</span><br><span class="line"></span><br><span class="line">   ;-----------------  打开A20  ----------------</span><br><span class="line">   in al,0x92</span><br><span class="line">   or al,0000_0010B</span><br><span class="line">   out 0x92,al</span><br><span class="line"></span><br><span class="line">   ;-----------------  加载GDT  ----------------</span><br><span class="line">   lgdt [gdt_ptr]</span><br><span class="line"></span><br><span class="line">   ;-----------------  cr0第0位置1  ----------------</span><br><span class="line">   mov eax, cr0</span><br><span class="line">   or eax, 0x00000001</span><br><span class="line">   mov cr0, eax</span><br><span class="line"></span><br><span class="line">   jmp dword SELECTOR_CODE:p_mode_start	     ; 刷新流水线，避免分支预测的影响,这种cpu优化策略，最怕jmp跳转，</span><br><span class="line">					     ; 这将导致之前做的预测失效，从而起到了刷新的作用。</span><br><span class="line">.error_hlt:		      ;出错则挂起</span><br><span class="line">   hlt</span><br><span class="line"></span><br><span class="line">[bits 32]</span><br><span class="line">p_mode_start:</span><br><span class="line">   mov ax, SELECTOR_DATA</span><br><span class="line">   mov ds, ax</span><br><span class="line">   mov es, ax</span><br><span class="line">   mov ss, ax</span><br><span class="line">   mov esp,LOADER_STACK_TOP</span><br><span class="line">   mov ax, SELECTOR_VIDEO</span><br><span class="line">   mov gs, ax</span><br><span class="line"></span><br><span class="line">; -------------------------   加载kernel  ----------------------</span><br><span class="line">   mov eax, KERNEL_START_SECTOR        ; kernel.bin所在的扇区号</span><br><span class="line">   mov ebx, KERNEL_BIN_BASE_ADDR       ; 从磁盘读出后，写入到ebx指定的地址</span><br><span class="line">   mov ecx, 200			       ; 读入的扇区数</span><br><span class="line"></span><br><span class="line">   call rd_disk_m_32</span><br><span class="line"></span><br><span class="line">   ; 创建页目录及页表并初始化页内存位图</span><br><span class="line">   call setup_page</span><br><span class="line"></span><br><span class="line">   ;要将描述符表地址及偏移量写入内存gdt_ptr,一会用新地址重新加载</span><br><span class="line">   sgdt [gdt_ptr]	      ; 存储到原来gdt所有的位置</span><br><span class="line"></span><br><span class="line">   ;将gdt描述符中视频段描述符中的段基址+0xc0000000</span><br><span class="line">   mov ebx, [gdt_ptr + 2]  </span><br><span class="line">   or dword [ebx + 0x18 + 4], 0xc0000000      ;视频段是第3个段描述符,每个描述符是8字节,故0x18。</span><br><span class="line">					      ;段描述符的高4字节的最高位是段基址的31~24位</span><br><span class="line"></span><br><span class="line">   ;将gdt的基址加上0xc0000000使其成为内核所在的高地址</span><br><span class="line">   add dword [gdt_ptr + 2], 0xc0000000</span><br><span class="line"></span><br><span class="line">   add esp, 0xc0000000        ; 将栈指针同样映射到内核地址</span><br><span class="line"></span><br><span class="line">   ; 把页目录地址赋给cr3</span><br><span class="line">   mov eax, PAGE_DIR_TABLE_POS</span><br><span class="line">   mov cr3, eax</span><br><span class="line"></span><br><span class="line">   ; 打开cr0的pg位(第31位)</span><br><span class="line">   mov eax, cr0</span><br><span class="line">   or eax, 0x80000000</span><br><span class="line">   mov cr0, eax</span><br><span class="line"></span><br><span class="line">   ;在开启分页后,用gdt新的地址重新加载</span><br><span class="line">   lgdt [gdt_ptr]             ; 重新加载</span><br><span class="line"></span><br><span class="line">;;;;;;;;;;;;;;;;;;;;;;;;;;;;  此时不刷新流水线也没问题  ;;;;;;;;;;;;;;;;;;;;;;;;</span><br><span class="line">;由于一直处在32位下,原则上不需要强制刷新,经过实际测试没有以下这两句也没问题.</span><br><span class="line">;但以防万一，还是加上啦，免得将来出来莫句奇妙的问题.</span><br><span class="line">   jmp SELECTOR_CODE:enter_kernel	  ;强制刷新流水线,更新gdt</span><br><span class="line">enter_kernel:    </span><br><span class="line">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span><br><span class="line">   call kernel_init</span><br><span class="line">   mov esp, 0xc009f000</span><br><span class="line">   jmp KERNEL_ENTRY_POINT                 ; 用地址0x1500访问测试，结果ok</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;-----------------   将kernel.bin中的segment拷贝到编译的地址   -----------</span><br><span class="line">kernel_init:</span><br><span class="line">   xor eax, eax</span><br><span class="line">   xor ebx, ebx		;ebx记录程序头表地址</span><br><span class="line">   xor ecx, ecx		;cx记录程序头表中的program header数量</span><br><span class="line">   xor edx, edx		;dx 记录program header尺寸,即e_phentsize</span><br><span class="line"></span><br><span class="line">   mov dx, [KERNEL_BIN_BASE_ADDR + 42]	  ; 偏移文件42字节处的属性是e_phentsize,表示program header大小</span><br><span class="line">   mov ebx, [KERNEL_BIN_BASE_ADDR + 28]   ; 偏移文件开始部分28字节的地方是e_phoff,表示第1 个program header在文件中的偏移量</span><br><span class="line">					  ; 其实该值是0x34,不过还是谨慎一点，这里来读取实际值</span><br><span class="line">   add ebx, KERNEL_BIN_BASE_ADDR</span><br><span class="line">   mov cx, [KERNEL_BIN_BASE_ADDR + 44]    ; 偏移文件开始部分44字节的地方是e_phnum,表示有几个program header</span><br><span class="line">.each_segment:</span><br><span class="line">   cmp byte [ebx + 0], PT_NULL		  ; 若p_type等于 PT_NULL,说明此program header未使用。</span><br><span class="line">   je .PTNULL</span><br><span class="line"></span><br><span class="line">   ;为函数memcpy压入参数,参数是从右往左依然压入.函数原型类似于 memcpy(dst,src,size)</span><br><span class="line">   push dword [ebx + 16]		  ; program header中偏移16字节的地方是p_filesz,压入函数memcpy的第三个参数:size</span><br><span class="line">   mov eax, [ebx + 4]			  ; 距程序头偏移量为4字节的位置是p_offset</span><br><span class="line">   add eax, KERNEL_BIN_BASE_ADDR	  ; 加上kernel.bin被加载到的物理地址,eax为该段的物理地址</span><br><span class="line">   push eax				  ; 压入函数memcpy的第二个参数:源地址</span><br><span class="line">   push dword [ebx + 8]			  ; 压入函数memcpy的第一个参数:目的地址,偏移程序头8字节的位置是p_vaddr，这就是目的地址</span><br><span class="line">   call mem_cpy				  ; 调用mem_cpy完成段复制</span><br><span class="line">   add esp,12				  ; 清理栈中压入的三个参数</span><br><span class="line">.PTNULL:</span><br><span class="line">   add ebx, edx				  ; edx为program header大小,即e_phentsize,在此ebx指向下一个program header </span><br><span class="line">   loop .each_segment</span><br><span class="line">   ret</span><br><span class="line"></span><br><span class="line">;----------  逐字节拷贝 mem_cpy(dst,src,size) ------------</span><br><span class="line">;输入:栈中三个参数(dst,src,size)</span><br><span class="line">;输出:无</span><br><span class="line">;---------------------------------------------------------</span><br><span class="line">mem_cpy:		      </span><br><span class="line">   cld</span><br><span class="line">   push ebp</span><br><span class="line">   mov ebp, esp</span><br><span class="line">   push ecx		   ; rep指令用到了ecx，但ecx对于外层段的循环还有用，故先入栈备份</span><br><span class="line">   mov edi, [ebp + 8]	   ; dst</span><br><span class="line">   mov esi, [ebp + 12]	   ; src</span><br><span class="line">   mov ecx, [ebp + 16]	   ; size</span><br><span class="line">   rep movsb		   ; 逐字节拷贝</span><br><span class="line"></span><br><span class="line">   ;恢复环境</span><br><span class="line">   pop ecx		</span><br><span class="line">   pop ebp</span><br><span class="line">   ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;-------------   创建页目录及页表   ---------------</span><br><span class="line">setup_page:</span><br><span class="line">;先把页目录占用的空间逐字节清0</span><br><span class="line">   mov ecx, 4096</span><br><span class="line">   mov esi, 0</span><br><span class="line">.clear_page_dir:</span><br><span class="line">   mov byte [PAGE_DIR_TABLE_POS + esi], 0</span><br><span class="line">   inc esi</span><br><span class="line">   loop .clear_page_dir</span><br><span class="line"></span><br><span class="line">;开始创建页目录项(PDE)</span><br><span class="line">.create_pde:				     ; 创建Page Directory Entry</span><br><span class="line">   mov eax, PAGE_DIR_TABLE_POS</span><br><span class="line">   add eax, 0x1000 			     ; 此时eax为第一个页表的位置及属性</span><br><span class="line">   mov ebx, eax				     ; 此处为ebx赋值，是为.create_pte做准备，ebx为基址。</span><br><span class="line"></span><br><span class="line">;   下面将页目录项0和0xc00都存为第一个页表的地址，</span><br><span class="line">;   一个页表可表示4MB内存,这样0xc03fffff以下的地址和0x003fffff以下的地址都指向相同的页表，</span><br><span class="line">;   这是为将地址映射为内核地址做准备</span><br><span class="line">   or eax, PG_US_U | PG_RW_W | PG_P	     ; 页目录项的属性RW和P位为1,US为1,表示用户属性,所有特权级别都可以访问.</span><br><span class="line">   mov [PAGE_DIR_TABLE_POS + 0x0], eax       ; 第1个目录项,在页目录表中的第1个目录项写入第一个页表的位置(0x101000)及属性(3)</span><br><span class="line">   mov [PAGE_DIR_TABLE_POS + 0xc00], eax     ; 一个页表项占用4字节,0xc00表示第768个页表占用的目录项,0xc00以上的目录项用于内核空间,</span><br><span class="line">					     ; 也就是页表的0xc0000000~0xffffffff共计1G属于内核,0x0~0xbfffffff共计3G属于用户进程.</span><br><span class="line">   sub eax, 0x1000</span><br><span class="line">   mov [PAGE_DIR_TABLE_POS + 4092], eax	     ; 使最后一个目录项指向页目录表自己的地址</span><br><span class="line"></span><br><span class="line">;下面创建页表项(PTE)</span><br><span class="line">   mov ecx, 256				     ; 1M低端内存 &#x2F; 每页大小4k &#x3D; 256</span><br><span class="line">   mov esi, 0</span><br><span class="line">   mov edx, PG_US_U | PG_RW_W | PG_P	     ; 属性为7,US&#x3D;1,RW&#x3D;1,P&#x3D;1</span><br><span class="line">.create_pte:				     ; 创建Page Table Entry</span><br><span class="line">   mov [ebx+esi*4],edx			     ; 此时的ebx已经在上面通过eax赋值为0x101000,也就是第一个页表的地址 </span><br><span class="line">   add edx,4096</span><br><span class="line">   inc esi</span><br><span class="line">   loop .create_pte</span><br><span class="line"></span><br><span class="line">;创建内核其它页表的PDE</span><br><span class="line">   mov eax, PAGE_DIR_TABLE_POS</span><br><span class="line">   add eax, 0x2000 		     ; 此时eax为第二个页表的位置</span><br><span class="line">   or eax, PG_US_U | PG_RW_W | PG_P  ; 页目录项的属性RW和P位为1,US为0</span><br><span class="line">   mov ebx, PAGE_DIR_TABLE_POS</span><br><span class="line">   mov ecx, 254			     ; 范围为第769~1022的所有目录项数量</span><br><span class="line">   mov esi, 769</span><br><span class="line">.create_kernel_pde:</span><br><span class="line">   mov [ebx+esi*4], eax</span><br><span class="line">   inc esi</span><br><span class="line">   add eax, 0x1000</span><br><span class="line">   loop .create_kernel_pde</span><br><span class="line">   ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">			   ;功能:读取硬盘n个扇区</span><br><span class="line">rd_disk_m_32:	   </span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">							 ; eax&#x3D;LBA扇区号</span><br><span class="line">							 ; ebx&#x3D;将数据写入的内存地址</span><br><span class="line">							 ; ecx&#x3D;读入的扇区数</span><br><span class="line">      mov esi,eax	   ; 备份eax</span><br><span class="line">      mov di,cx		   ; 备份扇区数到di</span><br><span class="line">;读写硬盘:</span><br><span class="line">;第1步：设置要读取的扇区数</span><br><span class="line">      mov dx,0x1f2</span><br><span class="line">      mov al,cl</span><br><span class="line">      out dx,al            ;读取的扇区数</span><br><span class="line"></span><br><span class="line">      mov eax,esi	   ;恢复ax</span><br><span class="line"></span><br><span class="line">;第2步：将LBA地址存入0x1f3 ~ 0x1f6</span><br><span class="line"></span><br><span class="line">      ;LBA地址7~0位写入端口0x1f3</span><br><span class="line">      mov dx,0x1f3                       </span><br><span class="line">      out dx,al                          </span><br><span class="line"></span><br><span class="line">      ;LBA地址15~8位写入端口0x1f4</span><br><span class="line">      mov cl,8</span><br><span class="line">      shr eax,cl</span><br><span class="line">      mov dx,0x1f4</span><br><span class="line">      out dx,al</span><br><span class="line"></span><br><span class="line">      ;LBA地址23~16位写入端口0x1f5</span><br><span class="line">      shr eax,cl</span><br><span class="line">      mov dx,0x1f5</span><br><span class="line">      out dx,al</span><br><span class="line"></span><br><span class="line">      shr eax,cl</span><br><span class="line">      and al,0x0f	   ;lba第24~27位</span><br><span class="line">      or al,0xe0	   ; 设置7～4位为1110,表示lba模式</span><br><span class="line">      mov dx,0x1f6</span><br><span class="line">      out dx,al</span><br><span class="line"></span><br><span class="line">;第3步：向0x1f7端口写入读命令，0x20 </span><br><span class="line">      mov dx,0x1f7</span><br><span class="line">      mov al,0x20                        </span><br><span class="line">      out dx,al</span><br><span class="line"></span><br><span class="line">;;;;;;; 至此,硬盘控制器便从指定的lba地址(eax)处,读出连续的cx个扇区,下面检查硬盘状态,不忙就能把这cx个扇区的数据读出来</span><br><span class="line"></span><br><span class="line">;第4步：检测硬盘状态</span><br><span class="line">  .not_ready:		   ;测试0x1f7端口(status寄存器)的的BSY位</span><br><span class="line">      ;同一端口,写时表示写入命令字,读时表示读入硬盘状态</span><br><span class="line">      nop</span><br><span class="line">      in al,dx</span><br><span class="line">      and al,0x88	   ;第4位为1表示硬盘控制器已准备好数据传输,第7位为1表示硬盘忙</span><br><span class="line">      cmp al,0x08</span><br><span class="line">      jnz .not_ready	   ;若未准备好,继续等。</span><br><span class="line"></span><br><span class="line">;第5步：从0x1f0端口读数据</span><br><span class="line">      mov ax, di	   ;以下从硬盘端口读数据用insw指令更快捷,不过尽可能多的演示命令使用,</span><br><span class="line">			   ;在此先用这种方法,在后面内容会用到insw和outsw等</span><br><span class="line"></span><br><span class="line">      mov dx, 256	   ;di为要读取的扇区数,一个扇区有512字节,每次读入一个字,共需di*512&#x2F;2次,所以di*256</span><br><span class="line">      mul dx</span><br><span class="line">      mov cx, ax	   </span><br><span class="line">      mov dx, 0x1f0</span><br><span class="line">  .go_on_read:</span><br><span class="line">      in ax,dx		</span><br><span class="line">      mov [ebx], ax</span><br><span class="line">      add ebx, 2</span><br><span class="line">			  ; 由于在实模式下偏移地址为16位,所以用bx只会访问到0~FFFFh的偏移。</span><br><span class="line">			  ; loader的栈指针为0x900,bx为指向的数据输出缓冲区,且为16位，</span><br><span class="line">			  ; 超过0xffff后,bx部分会从0开始,所以当要读取的扇区数过大,待写入的地址超过bx的范围时，</span><br><span class="line">			  ; 从硬盘上读出的数据会把0x0000~0xffff的覆盖，</span><br><span class="line">			  ; 造成栈被破坏,所以ret返回时,返回地址被破坏了,已经不是之前正确的地址,</span><br><span class="line">			  ; 故程序出会错,不知道会跑到哪里去。</span><br><span class="line">			  ; 所以改为ebx代替bx指向缓冲区,这样生成的机器码前面会有0x66和0x67来反转。</span><br><span class="line">			  ; 0X66用于反转默认的操作数大小! 0X67用于反转默认的寻址方式.</span><br><span class="line">			  ; cpu处于16位模式时,会理所当然的认为操作数和寻址都是16位,处于32位模式时,</span><br><span class="line">			  ; 也会认为要执行的指令是32位.</span><br><span class="line">			  ; 当我们在其中任意模式下用了另外模式的寻址方式或操作数大小(姑且认为16位模式用16位字节操作数，</span><br><span class="line">			  ; 32位模式下用32字节的操作数)时,编译器会在指令前帮我们加上0x66或0x67，</span><br><span class="line">			  ; 临时改变当前cpu模式到另外的模式下.</span><br><span class="line">			  ; 假设当前运行在16位模式,遇到0X66时,操作数大小变为32位.</span><br><span class="line">			  ; 假设当前运行在32位模式,遇到0X66时,操作数大小变为16位.</span><br><span class="line">			  ; 假设当前运行在16位模式,遇到0X67时,寻址方式变为32位寻址</span><br><span class="line">			  ; 假设当前运行在32位模式,遇到0X67时,寻址方式变为16位寻址.</span><br><span class="line"></span><br><span class="line">      loop .go_on_read</span><br><span class="line">      ret</span><br></pre></td></tr></table></figure>
<p>注意，在内核页表中，我们仍置US位为U，是因为内核的加载程序是运行在用户特权下的。由于我们目前只需要1MB的物理内存，每个页能映射4kB，因此只需要创建256个普通页表项，普通页表目录也只需要一个，并且这1MB的内存中，虚拟地址就等于物理地址。另外，第一个内核页表目录也指向256个普通页表项，因为我们需要让内核在这1MB的物理内存下被加载运行，之后的那1GB内核虚拟内存的页表和页表目录创建时就把P位置为0，表示他们不存在于内存中。</p>
<p>在加载完页表之后，我们就可以把控制寄存器CR0的第31位置为1，表示让CPU开启虚拟寻址模式，然后重新将全局描述符表加载到内核区域，再将内核加载到内核区的内存中就可以运行操作系统内核了。</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="虚拟机bochs的安装与配置"><a href="#虚拟机bochs的安装与配置" class="headerlink" title="虚拟机bochs的安装与配置"></a>虚拟机bochs的安装与配置</h3><p>这里使用2.6.2版本，下载地址： <a href="https://sourceforge.net/projects/bochs/files/bochs/2.6.2/" target="_blank" rel="noopener">https://sourceforge.net/projects/bochs/files/bochs/2.6.2/</a> </p>
<p>下载源代码文件之后解压进入目录，然后配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure \</span><br><span class="line">--prefix&#x3D;&#x2F;*你的安装目录*&#x2F; \</span><br><span class="line">--enable-debugger \</span><br><span class="line">--enable-disasm \</span><br><span class="line">--enable-iodebug \</span><br><span class="line">--enable-x86-debugger \</span><br><span class="line">--with-x \</span><br><span class="line">--with-x11</span><br></pre></td></tr></table></figure>
<p>然后<code>make</code>,如果报错说</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Makefile:179: recipe for target &#39;bochs&#39; failed</span><br><span class="line">make: *** [bochs] Error 1</span><br></pre></td></tr></table></figure>
<p>就再makefile里找到<code>LIBS =</code>，尾部加上<code>-lpthread</code>,注意这里不要再configure，否则makefile会被覆盖，再<code>make</code>，<code>make install</code>就可以了</p>
<p>进入bochs的目录，然后配置文件<code>bochsrc.disk</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># Configuration file for Bochs</span><br><span class="line"># 设置Bochs在运行过程中能够使用的内存: 32 MB</span><br><span class="line">megs: 32</span><br><span class="line"></span><br><span class="line"># 设置真实机器的BIOS和VGA BIOS</span><br><span class="line"># 修改成你们对应的地址</span><br><span class="line"></span><br><span class="line">romimage: file&#x3D;*bochs的目录*&#x2F;share&#x2F;bochs&#x2F;BIOS-bochs-latest</span><br><span class="line">vgaromimage: file&#x3D;*bochs的目录*&#x2F;bochs-2.6.2&#x2F;share&#x2F;bochs&#x2F;VGABIOS-lgpl-latest</span><br><span class="line"></span><br><span class="line"># 设置Bochs所使用的磁盘</span><br><span class="line"># 设置启动盘符</span><br><span class="line">boot: disk</span><br><span class="line"></span><br><span class="line"># 设置日志文件的输出</span><br><span class="line">log: bochs.out</span><br><span class="line"></span><br><span class="line"># 开启或关闭某些功能，修改成你们对应的地址</span><br><span class="line">mouse: enabled&#x3D;0</span><br><span class="line">keyboard:keymap&#x3D;*bochs的目录*&#x2F;share&#x2F;bochs&#x2F;keymaps&#x2F;x11-pc-us.map</span><br><span class="line"></span><br><span class="line"># 硬盘设置</span><br><span class="line">ata0: enabled&#x3D;1, ioaddr1&#x3D;0x1f0, ioaddr2&#x3D;0x3f0, irq&#x3D;14</span><br><span class="line"></span><br><span class="line"># 增加gdb支持，这里添加会报错，暂时不需要</span><br><span class="line"># gdbstub: enabled&#x3D;1, port&#x3D;1234, text_base&#x3D;0, data_base&#x3D;0, bss_base&#x3D;0</span><br></pre></td></tr></table></figure>
<p>然后运行<code>bin/bximage</code>，创建一个60M的虚拟硬盘，遇到选项全部回车，然后问size的时候填个60，然后把让你复制的这一行：<code>ata0-master: type=disk, path=&quot;hd60M.img&quot;, mode=flat, cylinders=121, heads=16, spt=63</code>复制到配置文件中，记得path改成绝对路径，bochs不认识相对路径</p>
<p>之后运行bochs就完事了</p>

    </div>

    
    
    
        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="https://chenyu-blog-img-1302348848.cos.ap-shanghai.myqcloud.com/social_app_add_code/wechat.jpg">
            <span class="icon">
              <i class="fab fa-weixin"></i>
            </span>

            <span class="label">WeChat</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/08/14/glibc-malloc-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="prev" title="glibc malloc 源码分析">
      <i class="fa fa-chevron-left"></i> glibc malloc 源码分析
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#简易内核实现笔记-一-——开启操作系统前的准备"><span class="nav-number">1.</span> <span class="nav-text">简易内核实现笔记(一) ——开启操作系统前的准备</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#BIOS"><span class="nav-number">1.1.</span> <span class="nav-text">BIOS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MBR"><span class="nav-number">1.2.</span> <span class="nav-text">MBR</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Loader"><span class="nav-number">1.3.</span> <span class="nav-text">Loader</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#保护模式"><span class="nav-number">1.3.1.</span> <span class="nav-text">保护模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#全局描述符表"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">全局描述符表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#A20-Gate"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">A20 Gate</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚拟地址空间"><span class="nav-number">1.3.2.</span> <span class="nav-text">虚拟地址空间</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#页表"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">页表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#附录"><span class="nav-number">1.4.</span> <span class="nav-text">附录</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#虚拟机bochs的安装与配置"><span class="nav-number">1.4.1.</span> <span class="nav-text">虚拟机bochs的安装与配置</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Chenyu ZHU</p>
  <div class="site-description" itemprop="description">Chenyu</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/ChenyuZhuWhiskey" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ChenyuZhuWhiskey" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:chenyu_zhu@protonmail.com" title="E-Mail → mailto:chenyu_zhu@protonmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chenyu ZHU</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
